---
title: "Assessing SHS Income Data"
# output: 
#   bookdown::gitbook:
#     split_by: section+number
#     config:
#       toc:
#         collapse: section
#         scroll_highlight: yes
#       fontsettings:
#         theme: white
#         family: sans
#       sharing: no
output:
  bookdown::word_document2:
    reference_docx: template.docx

---

```{r setup, include = FALSE}

# Set global chunk options

knitr::opts_chunk$set(
	echo = FALSE,
	fig.asp = 0.5,
	fig.width = 10,
	warning = FALSE)

# Load packages

library(plyr) # needed for groupwiseMedian function
library(tidyverse)
library(naniar) # for dealing with missing values
library(labelled) # to remove labels from imported data
library(scales) # for comma and percent formats
library(ggrepel) # for non-overlapping chart annotation
library(Hmisc) # for weighted quartiles
library(boot) # needed for groupwiseMedian function
library(readxl)

# Load functions

source("scr/functions.R")

# Load colour scheme and other strings

source("scr/strings.R")
source("scr/colours.R")

# Load datasets

adult_1819 <- readRDS("output/adult_1819.rds")
househol_1819 <- readRDS("output/househol_1819.rds")
benefits_1819 <- readRDS("output/benefits_1819.rds")
hbai1819 <- readRDS("output/hbai1819.rds")
person18 <- readRDS("output/person18.rds")
hhold18 <- readRDS("output/hhold18.rds")

# Create tidy datasets

source("scr/prepSHSdata.R")
source("scr/prepHBAIdata.R")

# Combine all data

source("scr/prepdata.R")

# Change some theme elements (charts)

theme_update(legend.position = "top",
             legend.title = element_blank(),
             panel.background = element_blank(),
             panel.grid.major.x = element_line(colour = "grey95"),
             panel.grid.minor.x = element_line(colour = "grey95"),
             panel.grid.major.y = element_line(colour = "grey95"),
             axis.ticks = element_blank(),
             text = element_text(size=16))

```

# Results

***

**Summary**

We compared net household income data from the SHS 2018 with that from the HBAI 2018/19 by looking at the main income components as well as total income. 

We found that overall, average earnings were reasonably similar between surveys, with SHS earnings slightly (but statistically significantly) higher than HBAI earnings. Note though that for lower household incomes, SHS earnings were slightly _lower_ than HBAI earnings. While average earnings agreed well for households with employed household heads, earnings for the small number of households with a self-employed head were much higher in the SHS compared to the HBAI, probably due to differences in survey methodology. Earnings drive total income of employed and self-employed households, which make up the majority of households in Scotland. For example, households where the head is employed have fairly consistent earnings levels across the two surveys, and therefore their total income also matches well. In contrast, households with a self-employed head show very different earnings levels in the two surveys, and therefore also very different income levels. 

Average benefit income was consistently lower in the SHS compared to the HBAI, caused by underreporting and non-reporting of benefits. The impact of under- and non-reporting of the State Pension dwarfed the impact of all other (also underreported) benefits and affects almost all pensioner households, because their main income source is the State Pension. Underreporting of disability benefits affects households where these benefits are a major or the main income source, such as those who are economically inactive due to disability or longterm illness. Benefit income drives total income of economically inactive and unemployed households. For example, pensioners' incomes largely consist of the State Pension and to a smaller degree, occupational pensions. Both are considerably lower in the SHS, and therefore total income of pensioners is lower. Similarly, a large part of total income of households with a disabled household head come from disability-related benefits, which are equally much lower in the SHS, resulting in too low total incomes.

The total income distribution is similar for both surveys, although the SHS distribution is slightly wider than the HBAI equivalent. As a result, a larger proportion of the population sit below the SHS poverty threshold in the SHS income distribution. 

Within the limited ability of comparing regional incomes between surveys, we found no indication that there are any local areas with particularly large income discrepancies.

In conclusion, while incomes between SHS and HBAI agree reasonably well, there are some types of households which cause problems: The largest group among them are pensioner households; other groups are households that are economically inactive due to disability, and households with a self-employed household head. 

The implications for poverty measurement are as follows: Any poverty rates based on the SHS will be higher than those based on the HBAI due to the shape of the income distribution and due to pensioners' incomes which are too low. It might therefore be best to exclude pensioners from any poverty analysis. Furthermore, when disaggregating statistics by economic status, one should be aware that poverty of self-employed households may be underestimated. And finally, regional poverty breakdowns should be possible where sample sizes allow. 

We would therefore recommend to continue to collect income data from all adults. We would also suggest to review how State Pension data is collected in the SHS, and whether changes to the questionnaire wording or data editing / imputation routines may improve the data quality for this key benefit.

***

## Introduction

From previous work done comparing SHS and HBAI data, we expect the average total income to be matching fairly well, even if the individual income components might not match well enough for detailed analysis due to the different remits of the two surveys and resulting methods. Here, we look at how the individual income components differ between the surveys and how that might affect different groups of the population differently.

We compared SHS 2018 income data (the new, broader definition, which includes income from other adults in the household) with HBAI 2018/19 income data. For the HBAI data, we used net income without the top-income adjustment. Except for this, the HBAI income definition we used is the same as that used for official household income and poverty statistics. This definition includes some components that are not available in the SHS, such as child income, and deductions (council tax, pension contributions, maintenance and child support payments, parental contributions to students living away from home, and student loan repayments). Of the deductions, council tax is the only information (indirectly) available in the SHS, and we deducted it from SHS household income. We calculated council tax using the council tax bands and imputing single-person discounts. Some council tax bands were added manually by the SHCS team. Where the council tax band was missing (half of the households in Shetland in the 2018 dataset, but only small numbers in other council areas), we assigned council tax band B, the most common band. 

We also looked at administrative data on benefits to quantify the amount of benefit underreporting in the SHS (and the HBAI).

Note that the income discussed here is net household income after benefits, direct taxes and national insurance contributions, and not taking housing costs into account (= before housing cost). We equivalised all incomes to account for household size, using the modified OECD scale, except when looking at aggregated incomes. 

For the analysis, 95% confidence intervals (C.I.) of the median were calculated using a bootstrapping method. For the HBAI, the bootstrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

In order to make appropriate comparisons across surveys, we recoded some common variables. For example, the definition of a child in the SHS was recoded to match that of the HBAI (i.e. includes 17-19 year-olds living at home, not married, and in full-time non-advanced education). Also, households in the SHS where the highest income householder (which is by definition the household head) is a student, but has earnings income and working hours, were recoded to full- or part-time employee households. This is because of differences in the definition of economic status between the two surveys. In the FRS ILO definition used here, students with jobs would be considered in work, whereas in SHS they would be considered students. After recoding, they will be considered in work in both surveys.

When using hyperlinks to the charts and tables, your browser BACK button will take you back to the previous section. Alternatively, opening the document twice in separate browser windows might make it easier to switch back an forth between text and tables.

## Earnings higher 

Median and mean earnings are higher in the SHS compared to the HBAI, driven by both, slightly higher average employed earnings, and much higher average self-employed earnings (sections \@ref(earnsumm) and \@ref(earneco)).

Median earnings of households where the head is **employed** (both, full- or part-time) match fairly well between surveys, but those where the head is **self-employed** have much higher earnings in the SHS. Checking with the (yet unpublished SHS 2019) dataset shows that this high level of self-employed earnings is consistent across years. This level may be much higher than in the HBAI because the SHS doesn't accept negative earnings responses. However, even when negative earnings in the HBAI were set to zero, the large difference in self-employed earnings persisted. It is possible that it is caused by questionnaire wording and survey time spent on self-employed earnings (section \@ref(earneco)).

Median earnings for some **household types** match fairly well between surveys, for example two adult households with and without children and single adult households, but single parent households slightly less so. Three+ adult households and those with one working-age adult and one pensioner differ considerably and show a wide variability in the HBAI. The latter group appears to have many cases in the HBAI with zero earnings, leading to a median of £0 (section \@ref(earnhhtype)).

Across household **income deciles**, median earnings in the SHS are higher than in the HBAI for higher incomes (deciles 5-10), but lower for deciles 2-4 (where the relative poverty threshold sits), and zero for the bottom decile, same as HBAI earnings. Note that HBAI earnings vary a lot in the lower deciles (section \@ref(earndec)).

Looking at **council areas**, note that HBAI data cannot be meaningfully analysed at a sub-Scotland level, as the weighting regime for the survey doesn’t account for geography within Scotland. However, if we do compare those council areas where household numbers are similar between SHS and HBAI (difference < 50%), median earnings match fairly well across surveys (section \@ref(earncounc)).

Earnings are the largest source of income for economically active households, and therefore earnings patterns determine income patterns for these households. For example, average earnings of households with a self-employed head are much higher in the SHS compared to the HBAI, and we will see later that total income for these households is also considerably higher in the SHS (sections \@ref(earneco) and \@ref(inceco)).

## Benefits lower 

Generally, the reported benefit income is lower in the SHS than in the HBAI. The lower benefit income in the SHS explains `r filter(incdiff, type == "ben") %>% select(diffcontr) %>% pull()` of the mean total income difference between these two surveys (section \@ref(compover)). (Note that when comparing benefit incomes, one should keep in mind that benefits in the HBAI are already underreported (to varying degrees, section \@ref(typover)). The lower benefit income in the SHS is caused by one or a combination of the following: 

* households not reporting they receive a benefit even though they do (= non-reporting)
* households not reporting all the benefits they receive (= non-reporting)
* households reporting a lower benefit amount then they actually receive (= underreporting)

Median benefit income across the two surveys matches best for those **household types** that don't get many benefits, such as working-age adult households without any children, where the median benefit income is zero in both surveys, but also working-age households with children, where average benefit income is only slightly lower in the SHS. Working-age households (defined here as households with no adults above state pension age) receive on average much lower benefits compared to pensioner households (section \@ref(bensumm)). 

For **Working-age households without children**, average benefit income in the top four income deciles is very small and mainly made up of disability benefits and Housing Benefit. In the lower income deciles, average benefit income increases and is made up increasingly (with lower incomes) with Housing Benefit. Other common benefits in the lower income deciles are Univeral Credit, disability benefits, Tax Credits, Council Tax Reduction and Income Support. Households in the second decile have the highest benefit income, whereas the benefit income of the bottom income decile is much lower, a common feature of survey-based income data, and probably partly due to various reporting errors. For **Working-age households with children**, Child Benefit is the main benefit, and reported aross all incomes. In the lower income deciles, Tax Credits dominate the benefit variety, followed by Housing Benefit and Universal Credit. When comparing benefit income for working-age households across the two surveys, it appears that average benefit amounts for most benefit types are lower in the SHS (section \@ref(benincdec)). We will see later that almost all benefits are underreported in the SHS compared to the HBAI (section \@ref(typover)).

**Pensioner households** have on average a much higher benefit income than working-age households (section \@ref(bensumm)) due to the State Pension (section \@ref(statepen)), which is the largest benefit income source and dwarfes income from other benefits such as Housing Benefit, Pension Credit and disability benefits. The average benefit income of pensioner households in the SHS is lower compared to the HBAI (section \@ref(bensumm)). The lower benefit income in the SHS is partly due to underreporting of the amount of state pension received. This can affect households with two pensioners twice as much compared to those with only one pensioner. In addition, many pensioners in the SHS do not report receiving any state pension at all (section \@ref(statepen)). In fact, almost all pensioner households in the HBAI report receipt of a benefit, but not so in the SHS: many pensioner households do not report receipt of any benefits (sections \@ref(bensumm) and \@ref(statepen)). More detail on the income sources of pensioner households is available in section [Pensioners’ incomes too low][Pensioners’ incomes too low].

Looking at household **economic status**, median benefit incomes for households where the highest income householder is a full-time employee or self-employed match well between surveys and show a small benefit amount and little variability. There is more variability and discrepancy in median benefit incomes for part-time employee households, with the average SHS benefit amounts lower. All other groups show considerable differences in median benefit incomes, with the SHS amount also consistently lower. We have seen the reasons for this for retired households earlier. As for households with a **permanently sick/disabled household** head, under- and non-reporting of Universal Credit and Tax Credits explains the benefit income difference (sections \@ref(beneco), \@ref(uc) and \@ref(tc)). Non-reporting of benefits is identified by comparing the number of households who report they receive the benefit. Underreporting of benefits is identified when the median benefit amounts (of those who report them) differ.

Looking across **council areas**, we need to remind ourselves that the HBAI is not designed for sub-Scotland level analysis, and household numbers in each council area are not designed to be accurate. However, removing those council areas with very large (>50%) discrepancies in number of households, and also excluding council areas with too small sample sizes, we're left with less than half of the council areas for comparison across surveys. In these, benefit incomes match reasonably well, but with very wide 95% confidence intervals (C.I.s) (section \@ref(bencounc)).

Benefits are the largest source of income for economically inactive households, such as pensioner households and those households that are inactive due to disability. Therefore, benefit underreporting hugely influences the total income for these households.

## Main benefit types

The largest benefit by far is the State Pension, which makes up almost half of all benefit income (`r filter(bencontr, type =="State Pension") %>% select(HBAI_share) %>% pull()` based on HBAI data). This is followed by the combined disability and carers' benefits (`r filter(bencontr, type =="Disability") %>% select(HBAI_share) %>% pull()`), followed by Tax Credits (`r filter(bencontr, type =="Tax Credits") %>% select(HBAI_share) %>% pull()`), Housing Benefit (`r filter(bencontr, type =="Housing Benefit") %>% select(HBAI_share) %>% pull()`), Child Benefit (`r filter(bencontr, type =="Child Benefit") %>% select(HBAI_share) %>% pull()`), Universal Credit (`r filter(bencontr, type =="Universal Credit") %>% select(HBAI_share) %>% pull()`), Pension Credit (`r filter(bencontr, type =="Pension Credit") %>% select(HBAI_share) %>% pull()`), and many smaller benefits (section \@ref(typover)).

All of the big benefits except for Housing Benefit are underreported in the SHS compared to the HBAI. (Note that the HBAI also underreports all of the big benefits compared to administrative data.) This could be due to underreporting of the amount received, not reporting a benefit, or a combination of both. Underreporting of State Pension and disability benefits together explains two thirds of the benefit income differences between the two surveys (section \@ref(typover)).

The underreporting of (all but one) benefits means that those household types with a large share of their income coming from benefits will be affected more, and show a lower income in the SHS compared to the HBAI. This largely affects households with low or no earnings: pensioners, who receive a large part of their income through the state pension (and other, smaller benefits such as Pension Credit, Housing Benefit, disability and carers' benefits and Winter Fuel Payment), and households with disabled household members who receive mainly Housing Benefit, disability and carers' benefits and Universal Credit (section \@ref(beneco)). I expect it also affects other low-earnings households through Tax Credits and Universal Credit. These households will show too low an income in the SHS.

To add more detail, **State Pension** is fairly well captured in the HBAI (covers `r filter(bencontr, type =="State Pension") %>% select(HBAI_capt) %>% pull()` of the aggregated admin data amount), but less so in the SHS (`r filter(bencontr, type =="State Pension") %>% select(SHS_capt) %>% pull()`) (section \@ref(typover)). This discrepancy explains `r filter(bencontr, type =="State Pension") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. It originates in a smaller number of pensioner households in the SHS reporting that they receive the State Pension, but also slightly smaller average payments. It is also possible that in SHS pensioner couple households only the state pension of one householder is reported (section \@ref(statepen)).

Combined **disability and carers' benefits** are captured to `r filter(bencontr, type =="Disability") %>% select(HBAI_capt) %>% pull()` in the HBAI, and only to `r filter(bencontr, type =="Disability") %>% select(SHS_capt) %>% pull()` in the SHS. These include Disability Living Allowance, Personal Independence Payment, Attendance Allowance, Employment Support Allowance, Carers' Allowance, Severe Disablement Allowance, and Industrial Injuries Disablement Benefit. I included Carers' Allowance in this list as I expect most carers to live in the same household as the person they care for. The discrepancy between HBAI and SHS disability benefit incomes explains a further `r filter(bencontr, type =="Disability") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. Disability benefits in the SHS are subject to both, underreporting of the amount, and non-reporting of receipt. Underreporting can be identified by comparing the average benefit amounts, and non-reporting can be identified by comparing the numbers of households who report that they receive this benefit (sections \@ref(typover), \@ref(disimportant), and \@ref(diswho)). A large part of the disability benefits goes to pensioner households; however, single adult households are also important recipients of these benefits (section \@ref(diswho)).

**Tax credits** are also underreported in the SHS compared to the HBAI, explaining a further `r filter(bencontr, type =="Tax Credits") %>% select(diffcontr) %>% pull()` of the benefit income difference between the surveys. A large part of this is part-time employee households underreporting the amount of Tax Credit they get. Both surveys vastly underreport Tax Credit compared to admin data (sections \@ref(typover) and \@ref(tc)).

**Housing Benefit** is underreported to a similar degree in both surveys, but comparable between surveys and across tenures (sections \@ref(typover) and \@ref(hb)).

**Child Benefit** income in the SHS is only slightly lower than in the HBAI, due to some households with two adults and children not reporting receipt of this benefit (sections \@ref(typover) and \@ref(cb)).

**Universal Credit** and **Pension Credit** are both vastly underreported in the SHS, explaining another `r filter(bencontr, type =="Universal Credit") %>% select(diffcontr) %>% pull()` and `r filter(bencontr, type =="Pension Credit") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. For both benefits, the received amounts are underreported. In addition, there are also fewer households in the SHS who report that they receive Pension Credit (sections \@ref(typover), \@ref(uc) and \@ref(pc)).

## Investment income much lower

Investment income makes up `r filter(incdiff, type == "inv") %>% select(HBAIshare) %>% pull()` of total income according to the HBAI. Investment income is hugely underreported in the SHS compared to the HBAI, even though we are using the HBAI data before top-income adjustments (which would correct top incomes upwards). This underreporting explains `r filter(incdiff, type == "inv") %>% select(diffcontr) %>% pull()` of the difference in total income (section \@ref(compover)).

The massively lower investment income in the SHS is largely due to the fact that only very few households in the SHS report any investment income, even though they report on average higher amounts. Most of investment income is held by retired households, by working-age couple households, and by the richest households; these are therefore the groups whose total income is affected more by investment income underreporting (section \@ref(investment)).

## Pensioners' incomes too low

**Single pensioner** and **pensioner couple** households get the major part of their income from benefits, which is mainly the State Pension. As the State Pension is underreported in the SHS (compared to the HBAI), household income is underrerported for these household types. The underreporting of State Pension is due to both, underreporting of the amount, and non-reporting of receiving the benefit. Many single pensioners in particular did not report that they received any State Pension at all. As for pensioner couple households, the numbers reporting that they did receive the State Pension was similar across surveys, but the average amount was lower in the SHS. It is possible that this is because only the State Pension of one person in the couple was reported in the SHS (section \@ref(pensources)). 

In addition to differences in benefit income (which is mainly the state pension), there are also large differences in occupational pensions and investment income. The difference in investment income is mostly due to non-reporting of investment income in the SHS compared to the HBAI. It should be noted that most of investment income in Scotland goes to retired households, see also sections [Investment income much lower][Investment income much lower] and \@ref(investment). Similarly, fewer people in the SHS report any occupational pension income, although average occupational pension income for those who receive it is comparable (section \@ref(occpen)).

Households with **one working-age adult and one pensioner** get a major part of their income through earnings, followed by benefits and occupational pensions (section \@ref(pensources)). This means that this group is less affected by underreported benefit income than the two other pensioner household types, and we will see that the median total income of this group matches better across surveys compared to single pensioner or pensioner couple households (section \@ref(inchhtype)).

And as mentioned before, **Pension Credit**, an income-related benefit for pensioners is subject to both, considerable underreporting of the amount, and non-reporting of receipt for SHS, compared to HBAI. This also contributes in a small part to the benefit income underreporting for pensioners (section \@ref(pc)).

## Income components 

Total income is largely made up of earnings, followed by benefits (which include the state pension) and occupational pensions (section \@ref(compover)). The lower the total income, the less important earnings and the more important benefits become (section \@ref(compdec)).

Overall, SHS total income is `r totdiff` lower than HBAI total income, even though the main component of total income, earnings, are higher in the SHS. However, this is more than offset by lower benefit and much lower investment income in the SHS, and then also from lower occupational pensions. Other income components are relatively small and therefore contribute less to the overall differences in income (section \@ref(compover)).

We have seen that the lower benefit income mostly affects pensioners (through the state pension) and households with disabled household members (through disability benefits) (section \@ref(beneco)).

We have also seen that most of the investment income goes to the wealthiest households. This will affect the income distribution most at the top, and might therefore not matter as much when looking at low income households. However, a large part of investment income goes to retired households, so this could exacerbate the income underreporting of these households even more (sections \@ref(investment) and \@ref(comptype)).

Across the **income distribution**, earnings drive the difference between surveys, as they are the largest component of total income. Average SHS earnings are lower than HBAI earnings at the bottom end of the income distribution, but higher at the top end. (section \@ref(compdist)).

As for **regional underreporting**, this is difficult to ascertain from comparison with HBAI data, because the HBAI's weighting regime doesn't allow sub-Scotland analysis. However, we would expect underreported incomes in those local areas that have a high share of their income coming from benefits, and also in local areas with many pensioners (whose main income source is the State Pension, a benefit).

The six council areas with the highest benefit shares are, according to SHS data, Dumfries & Galloway, Inverclyde, North Ayrshire, East Ayrshire, West Dunbartonshire, and Dundee City (section \@ref(comparea)). The eight council areas with the largest proportion of pensioners are Na h-Eileanan Siar, Argyll & Bute, Dumfries & Galloway, South Ayrshire, Scottish Borders, Orkney Islands, Angus, and Perth & Kinross (section \@ref(ageprofile)).

As for urban and rural areas, small towns and other (not large) urban areas have the highest shares of benefit income (section \@ref(comparea)). Remote small towns and remote rural areas on the other hand have the largest proportions of pensioners (section \@ref(ageprofile)).

## Total income overall

Having identified some issues in the measurement of the various income components, we will now see how these affect total income.

The income **distributions** in the SHS and the HBAI look largely similar, with the SHS income distribution being slightly wider, and the SHS **median** slightly lower (`r comma(SHSmedian, prefix = "£")` versus `r comma(HBAImedian, prefix = "£")`). Near the relative poverty threshold, the SHS cumulative income curve is higher, meaning more households sit below that threshold in the SHS compared to the HBAI. This means that more people are considered to be in relative poverty when using the SHS dataset compared to the HBAI dataset (section \@ref(incdist)).

Median incomes in the SHS are slightly higher than in the HBAI for higher income deciles; they level up in the sixth decile, and diverge towards lower incomes, with SHS incomes becoming markedly lower in the lowest decile. This shows that more households in the SHS have lower incomes compared to the HBAI, whereas the high income end of the distribution matches better between surveys. We have seen that this pattern is largely driven by earnings, the largest components of total income. In addition, the lower the income, the more important benefit income becomes, and the more affected total income is by benefit underreporting - although it appears that there is no benefit underreporting in the 3rd and 4th decile (sections \@ref(compdist) and \@ref(incdec)).

Median income 95% confidence intervals (C.I.s) overlap to some degree for most of the 17 **council areas** where we compared surveys. We excluded those council areas where the HBAI household populations were too far off (> 50% compared to SHS household population) or the sample sizes in the HBAI too small. For some council areas, the difference in median total income was quite large though, such as East Dunbartonshire, Aberdeenshire, Stirling, and Moray. This is probably driven by differences in earnings. None of these areas were noted earlier for particularly high proportions of pensioners or benefit income shares. However, C.I.s for all council areas and for both surveys are fairly wide, showing much income variation within each council area (section \@ref(inccounc)).

Median incomes match fairly well for **urban** and accessible rural areas. Median incomes in remote areas match slightly less well, but also have fairly wide C.I.s (section \@ref(incarea)).

Median incomes of **working-age adults** and **children** match well, but **pensioners**' incomes are much lower in the SHS, and C.I.s do not overlap. We saw that this is largely due to underreporting and non-reporting of the State Pension, as well as occupational pensions and investment income (sections \@ref(incage) and \@ref(pensources)).

Incomes for most **household types** match well, except, again, for pensioners, whose income is much lower in the SHS. Incomes of households with 3 or more working-age adults (and no children) have very wide C.I.s, indicating large variation of incomes in this group (section \@ref(inchhtype)).

Incomes of households where the household head (the highest income householder) is a **full- or part-time employee** match fairly well, which is no surprise as income from employed earnings also matches fairly well. As expected, incomes of the **retired** don't match well, similarly to pensioners' incomes in the age group and household type breakdowns. Incomes of households with a **disabled** household head also don't match too well, due to undereporting of disability benefits, which are the main income source of these households (section \@ref(inceco)).

Households where the head is **self-employed** had very variable incomes and a higher median in the SHS, driven by much higher earnings (sections \@ref(inceco) and \@ref(earneco)). This is consistent with the (yet unpublished and therefore not included) SHS 2019 data. Reasons for the higher earnings of the self-employed in the SHS could include that the SHS may not fully account for self-employed losses, or not in the same way as the HBAI. For example, the SHS doesn't accept negative earnings responses. Also, the definitions of self-employment may differ between surveys. Note that households where the head is self-employed make up only `r filter(ecoshares, HIHemp == "Self-Employed") %>% select(share) %>% pull()` of all households (according to SHS 2018), so maybe this issue isn't very important.

## Open questions

- How well do housing costs match? There are some inherent differences between surveys in what's included as a housing cost. The main difference is for home owners with a mortgage: While the HBAI considers only the mortgage interest as a housing cost, the SHS also includes capital repayments. Furthermore, the HBAI also includes rent, water and sewerage charges, and (structural) home insurance. In the SHS, housing costs also include rent.

- In the analysis here, we didn't use the usual HBAI BHC income variable on which the official income and poverty statistics are based, but income without top-income adjustments. The reason for this is that the top-income adjusted income figures are only available for gross income, but not net income. However, the effect on the median is small. The HBAI median without top-income adjustment is `r comma(HBAImedian, prefix = "£", accuracy = 1)`, whereas the top-income adjusted median is £517. We expect higher incomes to be affected more.

- Self-employed earnings are much higher in the SHS compared to the HBAI. Also, the SHS doesn't allow negative earnings responses. The difference in self-employed earnings between surveys is probably due to the questionnaire wording and interview time spent on getting this information.

- The bootstrapping mechanism that calculates the 95% confidence intervals of HBAI median incomes draws sub-samples from the survey sample via simple random sampling. However, it should draw the samples in the same way as the original sample was drawn, using the fairly complex sampling design of the FRS. This might widen the C.I.s even further. It may be possible to calculate more accurate confidence intervals for the HBAI data using a resamples dataset that DWP provide; however, this might be time consuming and is unlikely to add much new information.

- The SHS doesn't collect information on children's incomes. An Ipsos Mori report showed that children's income made up 1% of single parents' income in the FRS, and that it was even less important for couples households with children. Similarly, the SHS doesn't ask about children's benefits such as child DLA, but this might be captured via the parents' incomes. Disability benefit incomes for households with children don't look particularly bad. 

- Many pensioners in the SHS do not report that they receive state pension. Is this due to the question wording? Maybe model state pension instead of imputing it?


# Charts and tables

This part includes all tables and charts produced for the analysis. The survey data comes from the SHS 2018 and the HBAI 2018/19; and the administrative benefit data from StatXplore and the Scottish Government.

Tables and charts are subject to **suppressed data** where sample sizes are too small. For the HBAI, at least 50 cases in the sample are required to report on mean, median and total amounts, and at least 100 cases are required to report on number of individuals or households. Suppressed data in the tables is marked "..".

Note that the 95% **confidence intervals** (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

Note that the FRS is not designed to provide **sub-Scotland disaggregation**. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

**Adults** refer to working-age adults without children unless otherwise stated. **Pensioners** refer to people above state-pension age. **Children** refer to dependent children.

The **household head** is the person in the household with the highest income, or, where incomes are equal, the older person.

## Earnings {#earnings}

### Summary stats {#earnsumm}

Weekly net equivalised median (with 95% confidence interval) and mean household earnings, aggregated weekly earnings, and number of households (including all households):

```{r median_earnings}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = NULL,
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = NULL,
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

range <- rbind(HBAI_CI, SHS_CI) %>%
  mutate(CI = str_c("£", Normal.lower, "-£", Normal.upper),
         survey = ordered(survey)) %>%
  select(survey, CI)

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000)) %>%
  left_join(range, by = "survey") %>%
  select(survey, median, CI, everything()) %>%
  knitr::kable(align = "lrrrrrr")

```



Weekly net equivalised median (and 95% confidence interval) and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings (excluding households with no earnings):

```{r median_earnings2}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = NULL,
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI",
                              amount != 0) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = NULL,
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS",
                              amount != 0) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

range <- rbind(HBAI_CI, SHS_CI) %>%
  mutate(CI = str_c("£", Normal.lower, "-£", Normal.upper),
         survey = ordered(survey)) %>%
  select(survey, CI)

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000)) %>%
  left_join(range, by = "survey") %>%
  select(survey, median, CI, everything()) %>%
  knitr::kable(align = "lrrrrrr") 
```


### Earnings distribution {#earndist}

```{r earn_distributions}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  mutate(weight = ppwgt/sum(ppwgt)) %>%
  ggplot(aes(x = amount, 
             weight = weight, 
             colour = survey, fill = survey )) +
  geom_density(size = 1, alpha = 0.5, bw = 0.02) +
  scale_x_log10(labels = comma_format(prefix = "£"), limits = c(10, 10000)) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Net equivalised household earnings density distributions",
       subtitle = "Note log x scale",
       x = "Weekly equivalised net household earnings",
       y = NULL) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank(),
         panel.grid.minor.x = element_blank())

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  ggplot(aes(x = amount, weight = ppwgt, colour = survey, fill = survey )) +
  coord_cartesian(xlim = c(0, 1000)) +
  stat_ecdf(geom = "step", size = 1, alpha = 0.5) +
  scale_x_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000)) +
  scale_y_continuous(labels = percent_format()) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Cumulative net equivalised household earnings distributions",
       subtitle = "Note linear x scale",
       x = "Weekly equivalised net household earnings",
       y = "Proportion of people") +
   theme(panel.grid.minor.x = element_blank(),
         axis.text.y = element_text())

```

### by economic status {#earneco}

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households by economic status of household head (including all households):

```{r earnings_inc}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = fct_reorder2(HIHemp, survey, desc(total)),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
    arrange(desc(HIHemp)) %>%
    knitr::kable(align = "llrrrrr") 

```

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

```{r earnings_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI", 
                              HIHemp %in% empstatnames[1:3]) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS", 
                              HIHemp %in% empstatnames[1:3]) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, survey, desc(Median))) %>%
  filter(n >= 50) %>%
  ggplot() +
  geom_point(aes(x = HIHemp, 
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median equivalised household earnings',
         subtitle = "Includes all households; lines show overall medians") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) +
  theme(panel.grid.major.y = element_blank())

```

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings by economic status of household head (excluding households with no earnings):

```{r earnings_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = fct_reorder2(HIHemp, survey, desc(total)),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  arrange(desc(HIHemp)) %>%
  knitr::kable(align = "llrrrrr")

```

### by household type {#earnhhtype}

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households by household type (all households):
```{r earnings_hhtype_inc}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(hhtype) %>%
  mutate(median =  ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  knitr::kable(align = "lrrrrrr") 

```

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

Adults refer to working-age adults without children unless otherwise stated. Pensioners refer to people above state-pension age. Children refer to dependent children.

```{r earnings_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, desc(Median))) %>%
  filter(n >= 50) %>%
  ggplot() +
  geom_point(aes(x = hhtype, 
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings',
         subtitle = str_wrap("Includes households with and without earnings; sample >= 50; lines show overall medians", 75)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings by household type (excluding households with no earnings):
```{r earnings_hhtype_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(hhtype) %>%
  mutate(median =  ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  knitr::kable(align = "lrrrrrr")

```

### by income decile {#earndec}

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

```{r earnings_deciles}

# Earnings by hhld income decile

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)
# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         decile = factor(decile)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = decile, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = decile,
                   xend = decile,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings by household income decile',
         subtitle = 'Includes all households') +
  scale_y_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000, 1200)) +
  coord_flip(ylim = c(-25, 1175)) 

```


### by council area {#earncounc}

***

Note that the FRS is not designed to provide sub-Scotland disaggregation. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis further below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

```{r hhlds_council}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey, council) %>%
  summarise(households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  filter(sample >= 50) %>%
  select(-sample) %>%
  spread(survey, households) %>%
  filter(!is.na(HBAI)) %>%
  mutate(diff = (HBAI - SHS)/SHS,
         diffsize = ifelse(abs(diff) < 0.5, "HBAI", "SHS"),
         council = fct_reorder(council, diff)) %>%
  ggplot(aes(x = council, y = diff, fill = diffsize)) +
  geom_col(position = "dodge") +
  annotate("text", x = 18, y = 0.6, 
           label = "Difference > 50%",
           hjust = 0, colour = cols_survey[2],
           fontface = "bold") +
  scale_y_continuous(labels = percent_format(1)) +
  scale_fill_manual(values = cols_survey, guide = FALSE) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Difference in SHS and HBAI household populations by council area",
       subtitle = str_wrap("Positive values = HBAI population higher than SHS population; excludes councils with < 50 cases", 80)) 



```

***

Weekly net equivalised household earnings by council area (including all households, but excluding council areas where population differences are > 50%):
```{r earnings_council_inc}

tidydata %>%
  filter(type == "earn",
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%

  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") 


```

Note that the FRS is not designed to provide sub-Scotland disaggregation. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis further below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

```{r earnings_council_ci}

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "earn", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "earn", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(council = fct_reorder2(council, survey, desc(Median))) %>%
  ggplot() +
  geom_point(aes(x = council, y = Median, colour = survey), 
             size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings by council area',
         subtitle = str_wrap('Includes all households, councils with >= 50 cases, and councils where household population is off by < 50%; lines show Scotland medians', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-250, 800))

```

Weekly net equivalised household earnings by council area (excludes households with zero earnings, and council areas where population differences are > 50%):
```{r earnings_council_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0,
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%

  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr")

```

## Benefit income {#benefits}

### Summary stats {#bensumm}

Weekly benefit household income, equivalised median and mean, aggregated total, and number of households (including all households):
```{r median_benefits_inc}

all <- tidydata %>%
  filter(type == "ben") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "All") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0,
         chwgt == 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households with no children") %>%
  select(group, everything())

waakids <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0,
         chwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households with children") %>%
  select(group, everything())

pns <- tidydata %>%
  filter(type == "ben",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Pensioner households") %>%
  select(group, everything()) 

rbind(all, waa, waakids, pns) %>%
  knitr::kable(align = "llrrrrr") 

```

Weekly benefit household income, equivalised median and mean, aggregated total, and number of households receiving benefits (excludes households with no benefit income):
```{r median_benefits_exc}

all <- tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "All") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0,
         chwgt == 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households with no children") %>%
  select(group, everything())

waakids <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0,
         chwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households with children") %>%
  select(group, everything())

pns <- tidydata %>%
  filter(type == "ben",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Pensioner households") %>%
  select(group, everything()) 

rbind(all, waa, waakids, pns) %>%
  knitr::kable(align = "llrrrrr") 
```

### by decile and benefit type {#benincdec}

We combined the following disability and carers' benefits into "Disability":

- Personal Independence Payment
- Disability Living Allowance
- Employment and Support Allowance
- Attendance Allowance
- Carer's Allowance
- Incapacity Benefit
- Severe Disablement Allowance
- Industrial Injuries Disablement Benefit

We included Carer’s Allowance in this list as I expect most carers to live in the same household as the person they care for.

```{r benefits_types_decile_waa}

tidybens %>%
  filter(pnwgt == 0,
         chwgt == 0) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, decile, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            total = sum(hhwgt*amount*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey, decile) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(decile = factor(decile),
         type = fct_reorder(type, mean)) %>%
  ggplot(aes(x = decile, y = mean, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "Working-age households with no children - main benefits", 
       subtitle = str_wrap("Weekly equivalised mean benefit income of the five largest benefits in each income decile; includes households with and without any benefit income", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  theme(legend.position = "right",
        panel.grid.major.x = element_blank())

```

```{r benefits_types_decile_waakids}

tidybens %>%
  filter(pnwgt == 0,
         chwgt > 0) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, decile, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            total = sum(hhwgt*amount*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey, decile) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(decile = factor(decile),
         type = fct_reorder(type, total)) %>%
  ggplot(aes(x = decile, y = mean, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "Working-age households with children - main benefits", 
       subtitle = str_wrap("Weekly equivalised mean benefit income of the five largest benefits in each income decile; includes households with and without any benefit income", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  theme(legend.position = "right",
        panel.grid.major.x = element_blank())

```

```{r benefits_types_decile_pn}

tidybens %>%
  filter(pnwgt > 0) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, decile, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            total = sum(hhwgt*amount*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey, decile) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(decile = factor(decile),
         type = fct_reorder(type, total)) %>%
  ggplot(aes(x = decile, y = mean, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "Pensioner households - main benefits", 
       subtitle = str_wrap("Weekly equivalised mean benefit income of the five largest benefits in each income decile; includes households with and without any benefit income", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  theme(legend.position = "right",
        panel.grid.major.x = element_blank())

```

### by household type {#benhhtype}

Weekly household benefit income by household type, equivalised median and mean, aggregated total, and number of households  (including all households):
```{r benefits_hhtype_inc}

tidydata %>%
  filter(type == "ben") %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = sum(n)) %>%
  ungroup() %>%
  mutate(total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         hhtype = factor(hhtype, levels = hhtypenames),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£"))) %>%
  arrange(hhtype, survey) %>%
  knitr::kable(align = "llrrrrr") 

```


Note that this chart excludes the Two adults with children group due to too many zero values in the HBAI sample for this group.
```{r bens_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI",
                              hhtype != "Two adults with children") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata,
                              type == "ben",
                              survey == "SHS",
                              hhtype != "Two adults with children") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, Median)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = fct_rev(hhtype), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower,
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Equivalised weekly median household benefit income',
         subtitle = str_wrap("Includes households with and without benefit income; sample >= 50; excludes household type Two Adults with Children", 75)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800))

```

Weekly household benefit income by household type, equivalised median and mean, aggregated total, and number of households with benefit income (excludes households with no benefit income):
```{r benefits_hhtype_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = sum(n)) %>%
  ungroup() %>%
  mutate(total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         hhtype = factor(hhtype, levels = hhtypenames),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£"))) %>%
  arrange(hhtype, survey) %>%
  knitr::kable(align = "llrrrrr") 

```

### by economic status {#beneco}

Weekly household benefit income by economic status of the household head, equivalised median and mean, aggregated total, and number of households (including all households):
```{r benefits_eco_inc}

tidydata %>%
  filter(type == "ben") %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(HIHemp = factor(HIHemp, levels = empstatnames),
         total = ifelse(survey == "HBAI" & sample < 100, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 50, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 100, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 100, "..", comma(median, prefix = "£"))) %>%
  arrange(HIHemp, survey) %>%
  knitr::kable(align = "llrrrrr") 

```

```{r bens_eco_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, survey, Median)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = fct_rev(HIHemp), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Equivalised weekly median household benefit income',
         subtitle = "Includes households with and without benefit income; sample >= 50") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

Weekly household benefit income by economic status of the household head, equivalised median and mean, aggregated total, and number of households with benefit income (excludes households with no benefit income):
```{r benefits_eco_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(HIHemp = factor(HIHemp, levels = empstatnames),
         total = ifelse(survey == "HBAI" & sample < 100, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 50, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 100, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 100, "..", comma(median, prefix = "£"))) %>%
  arrange(HIHemp, survey) %>%
  knitr::kable(align = "llrrrrr") 

```

```{r benefits_eco_types, fig.asp = 0.8}

tidybens %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, HIHemp, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            total = sum(hhwgt*amount*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey, HIHemp) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(HIHemp = factor(HIHemp),
         type = fct_reorder(type, total)) %>%
  ggplot(aes(x = HIHemp, y = mean, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "Main benefits by economic status", 
       subtitle = str_wrap("Weekly equivalised mean benefit income of the five largest benefits for each group; includes households with and without any benefit income", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip() +
  theme(legend.position = "right",
        panel.grid.major.y = element_blank())
```        
        
### by council area {#bencounc}

Weekly benefit household income by council area, equivalised median and mean, aggegrated total and number of households (including all households; but excludes council areas with < 50 cases, and council areas where population differences between surveys are > 50%):
```{r benefits_council_inc}

tidydata %>%
  filter(type == "ben",
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..",  comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr")


```

```{r benefits_council_ci}

# Get councils with a large enough sample size (households with earnings > 0)

councilsn50 <- filter(tidydata, 
       type == "ben",
       amount != 0,
       survey == "HBAI") %>%
  group_by(council) %>%
  count() %>%
  filter(n >= 50) %>%
  select(council) %>% pull()

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "ben", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "ben", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         council = factor(council),
         council = fct_reorder2(council, survey, desc(Median))) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = council, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median benefit household income by council area',
         subtitle = str_wrap('Includes households with and without benefit income; councils with >= 50 cases; councils where household populations are off by < 50%', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800))

```

Weekly benefit household income by council area, equivalised median and mean, aggegrated total and number of households with benefit income (excludes households with no benefit income, council areas with < 50 cases, and council areas where population differences between surveys are > 50%):
```{r benefits_council_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0,
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..",  comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") 

```

## Types of benefits {#types}

### Overview over all benefits {#typover}

Aggregated weekly benefit amounts, and how much of the actual amounts (based on admin data) are captured by each survey:
```{r ben_types}

tidybens_agg %>%
  group_by(survey) %>%
  summarise(amount = sum(amount),
            type = "total") %>%
  spread(survey, amount) %>%
  mutate(capt_HBAI = percent(HBAI/Admin, 1),
         capt_SHS = percent(SHS/Admin, 1)) %>%
  mutate_at(c("Admin", "HBAI", "SHS"), comma_format(scale = 1E-6, accuracy = 1, prefix = "£", suffix = " million")) %>%
  knitr::kable(align = "lrrrrrrrr", col.names = c("", "Admin (aggr.)", "HBAI (aggr.)", "SHS (aggr.)", "HBAI (capt.)", "SHS (capt.)")) 


```

Aggregated weekly benefit amounts for each of the largest twelve benefits, each benefit's share of total benefit income (in the admin data and for each survey), how fully the _actual amounts_ (based on admin data) are captured by each survey, and how much each benefit contributes to the total benefit income difference between the two surveys:
```{r ben_types_detailed}

tidybens_agg %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(totshare = amount/sum(amount)) %>%
  gather(key, value, -survey, -type) %>%
  unite(measure, c(key, survey)) %>%
  spread(measure, value) %>%
  arrange(desc(amount_Admin)) %>%
  mutate(capt_HBAI = percent(amount_HBAI/amount_Admin, 1),
         capt_SHS = percent(amount_SHS/amount_Admin, 1),
         diff = abs(amount_HBAI-amount_SHS),
         totdiff = sum(diff, na.rm = TRUE),
         diffcontr = percent(diff/totdiff, 1)) %>%
  select(-totdiff, -diff) %>%
  mutate_at(c("amount_Admin", "amount_HBAI", "amount_SHS"), comma_format(scale = 1E-6, accuracy = 1, prefix = "£", suffix = " million")) %>%
  mutate_at(c("totshare_Admin", "totshare_HBAI", "totshare_SHS"), percent_format(1)) %>%
  head(12L) %>%
  knitr::kable(align = "lrrrrrrrrr", col.names = c("", "Admin (aggr.)", "HBAI (aggr.)", "SHS (aggr.)", "Admin (share)", "HBAI (share)", "SHS (share)", "HBAI (capt.)", "SHS (capt.)", "Contribution to HBAI-SHS difference")) 

```

```{r ben_types_chart, fig.asp = 0.8}
tidybens_agg %>%
  filter(type %in% tail(levels(type), 14L)) %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount)) %>%
  ggplot(aes(x = fct_reorder2(type, desc(survey), desc(amount)), y = amount, fill = survey)) +
  geom_col(position = "dodge") +
  geom_text(aes(y = amount + 8E5,
                label = str_c("£", comma(amount, scale = 1E-6), " m"), colour = survey),
            position =  position_dodge(width = 1),
            hjust = 0) +
  scale_fill_manual(values = cols_survey) +
  scale_colour_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(scale = 1E-6, suffix = " million", prefix = "£")) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Aggregated weekly benefit income of the largest benefits") +
  theme(panel.grid.major.y = element_blank())

```


Weekly equivalised mean benefit amounts for each of the largest twelve benefits (includes all households):
```{r ben_types_detailed_ave}

tidybens %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            sample = n()) %>%
  ungroup() %>%
  filter(sample >= 50) %>%
  select(-sample) %>%
  mutate(type = factor(type),
         type = fct_reorder2(type, survey, mean)) %>%
  arrange(type) %>%
  spread(survey, mean) %>%
  mutate_at(c("HBAI", "SHS"), comma_format(prefix = "£", 0.01)) %>%
  head(12L) %>%
  knitr::kable(align = "lrr", col.names = c("", "HBAI mean amount", "SHS mean amount")) 

```

Weekly equivalised **mean** benefit amounts for each of the most generous benefits (includes only households that receive the benefit; sample >= 50):
```{r ben_types_detailed_ave_inc}

tidybens %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  filter(amount != 0) %>%
  group_by(survey, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            sample = n()) %>%
  ungroup() %>%
  filter(sample >= 50) %>%
  select(-sample) %>%
  mutate(type = factor(type),
         type = fct_reorder2(type, desc(survey), mean)) %>%
  arrange(type) %>%
  spread(survey, mean) %>%
  mutate(HBAI = ifelse(is.na(HBAI), "..", comma(HBAI, prefix = "£")),
         SHS = ifelse(is.na(SHS), "..", comma(SHS, prefix = "£"))) %>%
  head(20L) %>%
  knitr::kable(align = "lrr", col.names = c("", "HBAI mean amount", "SHS mean amount")) 
```

### State Pension {#typstatepen}

See [Pensioners' incomes][Pensioners' incomes]

### Disability benefits - which are the most important? {#disimportant}

Disability benefits include:

- Employment and Support Allowance
- Disability Living Allowance
- Personal Independence Payment
- Attendance Allowance
- Carer's Allowance
- Severe Disablement Allowance
- Industrial Injuries Disablement Benefit
- Incapacity Benefit

Further below, these benefits are combined into a single "Disability" category. I also included Carer’s Allowance in this list as I expect most carers to live in the same household as the person they care for.

Individual disability benefits, aggregated weekly total, equivalised weekly median and mean, and numbers of households where someone received this benefit (excludes households who didn't report receiving this benefit):
```{r dis_benefits}

tidybens %>%
  filter(type %in% str_trunc(disbens, 30),
         amount != 0) %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(type = factor(type),
         type = fct_reorder(type, total),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         households = ifelse(sample < 100 & survey == "HBAI", "..", comma(households, 10000))) %>%
  arrange(desc(type)) %>%
  knitr::kable(align = "llrrrrr") 

```

### Disability benefits - who gets them? {#diswho}

Combined disability and carer's benefits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of a disability/carer's benefit:
```{r disability_all}

tidybens %>%
  filter(type %in% disbens,
         survey != "Admin",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") 
 
```

Household types

Combined disability and carer's benefits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of a disability/carer's benefit:
```{r disability_hhtype}

tidybens %>%
  filter(type %in% disbens,
         survey != "Admin",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, total),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  arrange(hhtype) %>%
  knitr::kable(align = "llrrrrr") 
 
```

Economic status of the household head

Combined disability and carer's benefits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of a disability/carer's benefit:
```{r disability_eco}

tidybens %>%
  filter(type %in% disbens,
         survey != "Admin",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(HIHemp = fct_reorder2(HIHemp, survey, total),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  arrange(HIHemp) %>%
  knitr::kable(align = "llrrrrr") 

tidybens %>%
  filter(type %in% disbens,
         survey != "Admin",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         HIHemp = fct_reorder(HIHemp, share)) %>%
  ggplot(aes(x = HIHemp, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = str_wrap("Share of aggregated disability benefit income by economic status", 65)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())
 
```

### Tax credits {#tc}

Tax credits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of tax credits by economic status of household head:
```{r tax_credits}

tidybens %>%
  filter(type == "Tax Credits",
         amount != 0,
         HIHemp %in% c("Part-time Employee", "Full-time Employee", "Self-Employed")) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(HIHemp) %>%
  knitr::kable(align = "llrrrrr")

```

### Housing Benefit {#hb}

Housing benefit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of housing benefit by tenure:
```{r housing_benefit}

tidybens %>%
  filter(type == "Housing Benefit",
         amount != 0) %>%
  group_by(survey, tenure) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(tenure = factor(tenure),
         tenure = fct_reorder2(tenure, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(tenure)) %>%
  knitr::kable(align = "llrrrrr") 

```

### Child Benefit {#cb}

Child benefit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of child benefit by household type (excludes households without any children and those not reporting any child benefit):
```{r child_benefit}

tidybens %>%
  filter(type == "Child Benefit",
         amount != 0,
         chwgt > 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr")

```

### Universal credit {#uc}

Universal Credit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of universal credit (excludes households with no universal credit):
```{r universal_credit}

tidybens %>%
  filter(type == "Universal Credit",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrrr") 

```

### Pension credit {#pc}

Pension Credit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of pension credit (excludes households with no pension credit):
```{r pension_credit}

tidybens %>%
  filter(type == "Pension Credit",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrrr")

```


## Single working-age adult benefit income {#singleadult}

Weekly benefit income (from all benefits) for single working-age adult households, aggregated total, equivalised median and mean, and number of single adult households (includes all households):
```{r single_adult_bens_inc}

tidydata %>%
  filter(hhtype == "Single adult",
         type == "ben") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "lrrrrr") 

```

Weekly benefit income (from all benefits) for single working-age adult households, aggregated total, equivalised median and mean, and number of single adult households receiving benefits (excludes households with no benefit income):
```{r single_adult_bens_exc}

tidydata %>%
  filter(hhtype == "Single adult",
         type == "ben",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "lrrrrr") 

```

Weekly benefit income for single working-age adult households from the largest benefits - aggregated total, equivalised median and mean, and number of single adult households receiving each benefit:
```{r single_adult_bens_types}

tidybens %>%
  mutate(type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  filter(hhtype == "Single adult",
         amount != 0) %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(type = factor(type),
         type = fct_reorder2(type, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  filter(sample > 30) %>%
  arrange(desc(type)) %>%
  head(6L) %>%
  knitr::kable(align = "llrrrrr")

```

## Investment income {#investment}

Weekly investment income, equivalised mean and median, aggregated total, and number of households with investment income (excludes households with no investment income):
```{r investment_inc}

tidydata %>%
  filter(type == "inv") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrr")

```

Weekly investment income, equivalised mean and median, aggregated total, and number of households with investment income (excludes households with no investment income):
```{r investment_exc}

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrr") 

```

Who has income from investments?

```{r investment_eco}

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         HIHemp = fct_reorder(HIHemp, share)) %>%
  ggplot(aes(x = HIHemp, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across household types") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         hhtype = fct_reorder(hhtype, share)) %>%
  ggplot(aes(x = hhtype, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across household types") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, decile) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across income deciles") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

## Pensioners' incomes {#pensioners}

### Pensioners' income sources {#pensources}

Weekly mean equivalised total income and income sources (includes all pensioner households):
```{r pensiones_sources_b}

tidydata %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner"),
         type %in% c("total", "earn", "ben", "occ", "inv")) %>%
  group_by(survey, type, hhtype) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt, na.rm = TRUE),
            sample = n()) %>% 
  filter(sample >= 50) %>%
  ggplot(aes(x = type, y = mean, fill = survey)) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = comma_format(prefix = "£")) +
  facet_wrap(vars(hhtype)) +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Mean equivalised weekly income and main income sources for pensioner households", 70)) +
   theme(panel.grid.major.x = element_blank())
```

Number of pensioner households who report they receive each type of income (income types based on fewer than 100 cases in the sample are excluded):
```{r pensioners_sources_c}

tidydata %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner"),
         amount != 0,
         type %in% c("earn", "ben", "occ", "inv")) %>%
  group_by(survey, type, hhtype) %>%
  summarise(households = sum(hhwgt),
            sample = n()) %>% 
  filter(sample >= 100) %>%
  select(hhtype, type, households, survey) %>%
  spread(survey, households) %>%
  mutate(HBAI = ifelse(is.na(HBAI), "..", comma(HBAI, 10000)),
         SHS = ifelse(is.na(SHS), "..", comma(SHS, 10000))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrr") 

```

### Pensioners' benefit types {#penbens}

```{r benefits_types_pntype}

tidybens %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner")) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, hhtype, type) %>%
  summarise(total = sum(hhwgt*amount*equ),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  group_by(survey, hhtype) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(type = fct_reorder(type, mean)) %>%
  ggplot(aes(x = hhtype, y = mean, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "What are the main benefits for each type of pensioner household?", 
       subtitle = str_wrap("Weekly mean benefit income of the five most common benefits in each household type; includes all pensioner households", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  theme(legend.position = "right") +
   theme(panel.grid.major.x = element_blank())

```

### State pension {#statepen}

State Pension - aggregate weekly amount, equivalised weekly median and mean, and number of pensioner households (includes all pensioner households):
```{r state_pension_hhtype_inc}

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         hhtype = "All pensioner households") %>%
  select(survey, hhtype, everything()) %>%
  knitr::kable(align = "lrrrrr") 

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr")

```

State Pension - aggregate weekly amount, equivalised weekly median and mean, and number of pensioner households in receipt of State Pension (excluding households with no state pension):
```{r state_pension_hhtype_exc}

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         hhtype = "All pensioner households") %>%
  select(survey, hhtype, everything()) %>%
  knitr::kable(align = "lrrrrr") 

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr") 

```

### Occupational pensions {#occpen}

Occupational Pensions - aggregate weekly amount, equivalised weekly median and mean, and number of households (includes all households):
```{r occ_pension_inc}

pns <- tidydata %>%
  filter(type == "occ",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Pensioner households") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "occ",
         pnwgt == 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Working-age households") %>%
  select(group, everything())

all <- tidydata %>%
  filter(type == "occ") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "All households") %>%
  select(group, everything())

rbind(all, pns, waa) %>%
  knitr::kable(align = "lllrrrrr") 

```

```{r occ_pen_eco}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, HIHemp) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         HIHemp = fct_reorder(HIHemp, share)) %>%
  ggplot(aes(x = HIHemp, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income across household types", 80)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

```{r occ_pen_hhtype}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, hhtype) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         hhtype = fct_reorder(hhtype, share)) %>%
  ggplot(aes(x = hhtype, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income by economic status of household head", 75)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

```{r occ_pen_dec}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, decile) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income across household income deciles", 80)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

Occupational Pensions - aggregate weekly amount, equivalised weekly median and mean, and number of households in receipt of occupational pensions (excluding households with no occupational pensions):
```{r occ_pension_exc}

pns <- tidydata %>%
  filter(type == "occ",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Pensioner households") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "occ",
         pnwgt == 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Working-age households") %>%
  select(group, everything())

all <- tidydata %>%
  filter(type == "occ",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "All households") %>%
  select(group, everything())

rbind(all, pns, waa) %>%
  knitr::kable(align = "lllrrrrr") 

```

## Self-employed's incomes {#selfemp}

Total weekly income and income sources of households with a self-employed household head - equivalised mean and median, aggregated total, and number of households (all households):
```{r selfemployed_sources}

tidydata %>%
  filter(HIHemp == "Self-Employed") %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100 | survey == "SHS" & sample < 30, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  #filter(sample >=30 ) %>%
  arrange(type) %>%
  knitr::kable(align = "llrrrrr") 

```

## Income components {#components}

### Overview over income components {#compover}

In each survey, how much does each income source contribute to total income? The income components are earnings, benefits, occupational pensions, investment income, other, private benefits, and deductions.

```{r components}

tidydata %>%
  group_by(survey, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt)) %>%
  ggplot(aes(x = type,
           y = mean,
           fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = ifelse(type == "ded", mean + 50, mean + 20),
                label = comma(mean),
                colour = survey),
            show.legend = FALSE,
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_colour_manual(values = cols_survey) +
  scale_y_continuous(label = comma_format(prefix = "£")) +
  labs(title = str_wrap("Weekly equivalised mean income - total income and income components", 70), x = NULL, y = NULL) +
   theme(panel.grid.major.x = element_blank())

```

And how much does each income component contribute to the _difference_ in total income? 

Equivalised weekly mean amount in each survey, the absolute difference between the surveys for each income component, and how much each component contributes to the difference in total mean income. Note that these contributions are based on absolute differences and are therefore all positive percentages. There are of course other ways to illustrate the relative importance of each income component:
```{r mean_components}

tidydata %>%
  group_by(survey, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt)) %>%
  spread(survey, mean) %>%
  mutate(diff = HBAI - SHS,
         absdiff = abs(diff),
         totdiff = sum(absdiff[2:8]),
         diffcontr = ifelse(type == "total", 1, abs(diff)/totdiff)) %>%
  mutate(HBAI = comma(HBAI, prefix = "£"),
         SHS = comma(SHS, prefix = "£"),
         diff = comma(diff, prefix = "£"),
         diffcontr = percent(diffcontr, 1)) %>%
  select(type, HBAI, SHS, diff, diffcontr) %>%
  mutate(type = factor(type, levels = inctypes)) %>%
  knitr::kable(align = "lrrrr") 

```


### What drives the survey differences across the income distribution {#compdist}

For each household income decile, we looked at the equivalised weekly mean income of the main income components, earnings and benefits. This shows that it is _earnings_ that drive the total income distribution, resulting in lower SHS incomes in the lower income deciles, and higher SHS incomes in the top income deciles:
```{r mean_comp_quintiles, fig.asp = 0.8}

tidydata %>%
  filter(type %in% c("earn", "ben")) %>%
  group_by(survey, decile, type) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = mean, fill = survey)) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = str_wrap("Weekly mean net equivalised household income for the main income types by income decile", 70),
       subtitle = "Includes all households") +
  theme(panel.grid.major.x = element_blank()) +
  facet_wrap(~type, ncol = 1)

```

### Income sources by income decile {#compdec}

```{r component_shares_decile}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded",
         amount >= 0) %>%
  group_by(survey, decile, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  group_by(survey, decile) %>%
  ggplot(aes(x = decile, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by (total) household income decile", 70),
       subtitle = "Excludes negative incomes and deductions") +
  facet_wrap(~survey, nrow = 2) +
  theme(legend.position = "right",
        axis.ticks = element_blank()) +
   theme(panel.grid.major.x = element_blank())

```

```{r component_shares_decile_abs, fig.asp = 1}

tidydata %>%
  filter(type != "total") %>%
  group_by(survey, decile, type) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt),
            sample =  n()) %>%
  ungroup() %>%
  filter(decile < 5) %>%
  mutate(decile = factor(decile)) %>%
  
  group_by(survey, decile) %>%
  mutate(total = sum(mean)) %>%
  ggplot(aes(x = survey, y = mean, fill = type)) +
  geom_col(position = "stack") +
  geom_point(aes(y = total), show.legend = FALSE) +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Weekly mean equivalised total income and income components in the bottom four (total) household income deciles", 70),
       subtitle = "Includes all income types and all households; dots show mean total income") +
  facet_wrap(~decile) +
  theme(legend.position = "right",
        axis.ticks = element_blank()) +
   theme(panel.grid.major.x = element_blank())

```

### Income sources by council area and urban/rural area {#comparea}

```{r inc_sources_council, fig.asp = 0.9}

tidydata %>%
  filter(type != "total",
         type != "ded",
         survey == "SHS") %>%
  group_by(survey, type, council) %>%
  summarise(total = sum(amount),
            n = n()) %>%
  group_by(survey, council) %>%
  mutate(share = total/sum(total)) %>%
  ungroup() %>%
  mutate(survey = fct_reorder(survey, share),
         type = fct_shift(type, 2),
         council = fct_reorder2(council, desc(type), desc(share))) %>%
  filter(n >= 50) %>%
  ggplot(aes(x = council, y = share, fill = type)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  coord_flip() +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Income sources as a share of aggregated total income by council area, SHS", 65),
       subtitle = "Excludes deductions") +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())
  
```

```{r inc_sources_urbrur}

tidydata %>%
  filter(type != "total",
         type != "ded",
         survey == "SHS") %>%
  group_by(type, urbrur) %>%
  summarise(total = sum(amount),
            n = n()) %>%
  group_by(urbrur) %>%
  mutate(share = total/sum(total)) %>%
  ungroup() %>%
  mutate(type = fct_shift(type, 2),
         urbrur = fct_rev(urbrur)) %>%
  ggplot(aes(x = urbrur, y = share, fill = type)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format() ) +
  coord_flip() +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Income sources as a share of aggregated total income by urban/rural class, SHS", 65),
       subtitle = "Excludes deductions") +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())
  
```

### Age profile of council areas and urban/rural areas {#ageprofile}

```{r ages_council, fig.asp = 0.9}

tidydata %>%
  filter(type == "total",
         survey == "SHS") %>%
  group_by(council) %>%
  summarise(sample = n(),
            people = sum(ppwgt),
            children = sum(chwgt),
            waadults = sum(wawgt),
            pensioners = sum(pnwgt)) %>%
  mutate(children = children/people,
         adults = waadults/people,
         pensioners = pensioners/people) %>%
  select(council, children, adults, pensioners) %>%
  gather(group, share, -council) %>%
  ungroup() %>%
  mutate(group = factor(group, levels = people),
         group = fct_rev(group),
         council = fct_reorder2(council, desc(group), desc(share))) %>%
  ggplot(aes(x = council, y = share, fill = group)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = wes_palettes[["IsleofDogs1"]]) +
  scale_y_continuous(labels = percent_format()) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Age profile of council areas, SHS",
       subtitle = "Proportion of children, working-age adults and pensioners in each council") +
  guides(fill = guide_legend(reverse = TRUE)) +
   theme(panel.grid.major.y = element_blank())
  
```

```{r ages_urbrur}

tidydata %>%
  filter(type == "total",
         survey == "SHS") %>%
  group_by(urbrur) %>%
  summarise(sample = n(),
            people = sum(ppwgt),
            children = sum(chwgt),
            waadults = sum(wawgt),
            pensioners = sum(pnwgt)) %>%
  mutate(children = children/people,
         adults = waadults/people,
         pensioners = pensioners/people) %>%
  select(urbrur, children, adults, pensioners) %>%
  gather(group, share, -urbrur) %>%
  ungroup() %>%
  mutate(group = factor(group, levels = people),
         group = fct_rev(group),
         urbrur = fct_rev(urbrur)) %>%
  ggplot(aes(x = urbrur, y = share, fill = group)) + 
  geom_col(position = "stack") +
  geom_text(aes(y = ifelse(group == "children", 0.05, ifelse(group == "pensioners", 0.85, 0.5)),
                label = percent(share, 1)),
            colour = "white",
            hjust = 0,
            fontface = "bold") +
  scale_fill_manual(values = wes_palettes[["IsleofDogs1"]]) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Age profile of urban/rural areas, SHS") +
  theme(axis.text.x = element_blank(),
        axis.ticks = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
   theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank())
  
```

### Income sources by household type and economic status {#comptype}

```{r component_shares_hhtype}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded") %>%
  group_by(survey, hhtype, type) %>%
  summarise(amount = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, desc(type), desc(amount))) %>%
  ggplot(aes(x = hhtype, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by household type", 60),
       subtitle = "Excludes deductions") +
  coord_flip() +
  facet_wrap(~survey, ncol = 2) +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())

```

```{r component_shares_eco}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded") %>%
  group_by(survey, HIHemp, type) %>%
  summarise(amount = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, desc(type), desc(amount))) %>%
  filter(sample >= 50) %>%
  ggplot(aes(x = HIHemp, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by economic status of household head", 60),
       subtitle = "Excludes deductions; sample >= 50") +
  coord_flip() +
  facet_wrap(~survey, ncol = 2) +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())

```

## Total income {#income}
### Income distribution {#incdist}

```{r income_distributions}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey) %>%
  mutate(weight = ppwgt/sum(ppwgt)) %>%
  ggplot(aes(x = amount, 
             weight = weight, 
             colour = survey, fill = survey )) +
  geom_vline(xintercept = HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = SHSmedian, colour = cols_survey[2]) +
  geom_vline(xintercept = 0.6*HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = 0.6*SHSmedian, colour = cols_survey[2]) +
  geom_density(size = 1, alpha = 0.5, bw = 0.02) +
  scale_x_log10(labels = comma_format(prefix = "£"), limits = c(20, 10000)) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Net equivalised household income density distributions",
       subtitle = "Vertical lines show poverty thresholds and medians; note log x scale",
       x = "Weekly equivalised net household income",
       y = NULL) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank(),
         panel.grid.minor.x = element_blank())

tidydata %>%
  filter(type == "total") %>%
  group_by(survey) %>%
  ggplot(aes(x = amount, weight = ppwgt, colour = survey, fill = survey )) +
  geom_vline(xintercept = HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = SHSmedian, colour = cols_survey[2]) +
  geom_vline(xintercept = 0.6*HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = 0.6*SHSmedian, colour = cols_survey[2]) +
  coord_cartesian(xlim = c(0, 1000)) +
  stat_ecdf(geom = "step", size = 1, alpha = 0.5) +
  geom_text(data = tail(tidydata, 1L), 
            aes(x = HBAImedian + 20, y = 1, label = "Medians"), 
            colour = "grey20",
            hjust = 0, 
            show.legend = FALSE) +
  geom_text(data = tail(tidydata, 1L), 
            aes(x = 0.6*HBAImedian + 10, y = 1, label = "Poverty lines"), 
            colour = "grey20",
            hjust = 0, 
            show.legend = FALSE) +
  scale_x_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000)) +
  scale_y_continuous(labels = percent_format()) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Cumulative net equivalised household income distributions",
       subtitle = "Note linear x scale",
       x = "Weekly equivalised net household income",
       y = "Proportion of people") +
   theme(panel.grid.minor.x = element_blank(),
         axis.text.y = element_text())

```

### Median income by income decile {#incdec}

```{r income_deciles}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey, decile) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = 40,
                label = comma(median, accuracy = 1, prefix = "£")),
            colour = 'white',
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = "Weekly median net equivalised household income by income decile",
       subtitle = "All households") +
  theme(panel.grid.major.x = element_blank())

```

```{r income_deciles_pn}

tidydata %>%
  filter(type == "total",
         pnwgt > 0) %>%
  group_by(survey, decile) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = 40,
                label = comma(median, accuracy = 1, prefix = "£")),
            colour = 'white',
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = "Weekly median net equivalised household income by income decile",
       subtitle = "Pensioner households") +
  theme(panel.grid.major.x = element_blank())

```

```{r income_deciles_wa}

tidydata %>%
  filter(type == "total",
         pnwgt == 0,
         chwgt == 0) %>%
  group_by(survey, decile) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = 40,
                label = comma(median, accuracy = 1, prefix = "£")),
            colour = 'white',
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = "Weekly median net equivalised household income by income decile",
       subtitle = "Working-age households without children") +
  theme(panel.grid.major.x = element_blank())

```

```{r income_deciles_ch}

tidydata %>%
  filter(type == "total",
         pnwgt == 0,
         chwgt > 0) %>%
  group_by(survey, decile) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = 40,
                label = comma(median, accuracy = 1, prefix = "£")),
            colour = 'white',
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = "Weekly median net equivalised household income by income decile",
       subtitle = "Households with children") +
  theme(panel.grid.major.x = element_blank())

```

### Median income by council area {#inccounc}

Weekly median net equivalised household income and 95% confidence interval of the median:
```{r median_council_ci, fig.asp = 0.7}

# Chart - Median income by council with C.I.
# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI",
                              council %in% popokcouncils) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

HBAI_CI_all <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3) %>%
  mutate(survey = "HBAI") %>%
  select(survey, Median, n, Conf.level, Normal.lower, Normal.upper)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS",
                              council %in% popokcouncils) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI_all <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3) %>%
  mutate(survey = "SHS") %>%
  select(survey, Median, Normal.lower, Normal.upper, Conf.level,  n)

rbind(HBAI_CI_all, SHS_CI_all) %>%
  select(survey, Median, Normal.lower, Normal.upper, Conf.level,  n) %>%
  mutate_at(c("Median", "Normal.lower", "Normal.upper"), comma_format(1, prefix = "£")) %>%
           knitr::kable(align = "lrrrrr") 


SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(council = fct_reorder2(council, survey, desc(Median))) %>%
  ggplot() +
  geom_hline(yintercept = HBAImedian, 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = SHSmedian, 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
  geom_point(aes(x = council,
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                   y = Normal.lower, 
                   yend = Normal.upper,
                   colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = str_wrap('Excludes council areas with large population discrepancies; lines show Scotland median', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 
  
```

### Median income by urban/rural area {#incarea}

```{r median_urbrur_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "urbrur",
                data = filter(tidydata, type == "total", survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "urbrur",
                data = filter(tidydata, type == "total", survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  filter(!is.na(Median)) %>%
  ggplot(aes(x = fct_rev(urbrur), y = Median)) +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(colour = survey), size = 2) +
  geom_segment(aes(xend = urbrur,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

### Median income by age group {#incage} 

```{r median_agegroup_ci}

# Note that HBAI bootstrap mechanism is SRS!

ch_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>% 
                mutate(weight = chwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

wa_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>% 
                mutate(weight = wawgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

pn_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, type == "total", survey == "HBAI") %>% 
                mutate(weight = pnwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

ch_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = chwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

wa_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = wawgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

pn_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = pnwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

ch_HBAI_CI$group <- "Children"
wa_HBAI_CI$group <- "WorkingAgeAdults"
pn_HBAI_CI$group <- "Pensioners"

ch_SHS_CI$group <- "Children"
wa_SHS_CI$group <- "WorkingAgeAdults"
pn_SHS_CI$group <- "Pensioners"

HBAI_CI <- rbind(ch_HBAI_CI, wa_HBAI_CI, pn_HBAI_CI) %>%
  mutate(survey = "HBAI")

SHS_CI <- rbind(ch_SHS_CI, wa_SHS_CI, pn_SHS_CI) %>%
  mutate(survey = "SHS")

rbind(HBAI_CI, SHS_CI) %>%
  select(survey, group, Median, Normal.lower, Normal.upper, n) %>%
  mutate(group = factor(group, levels = agegrouplevels),
         group = fct_rev(group)) %>%
  ggplot() +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = group, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = group,
                   xend = group,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

### Median income by household type {#inchhtype}

```{r median_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  filter(n >= 50) %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, desc(Median))) %>%
  ggplot(aes(x = hhtype, y = Median)) +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = hhtype, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

### Median income by economic status of highest income householder {#inceco}

```{r median_eco_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(HIHemp <- factor(HIHemp, levels = empstatnames),
         HIHemp = fct_reorder2(HIHemp, survey, Median)) %>%
  filter(n >= 50 ) %>% 
  ggplot() +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = fct_rev(HIHemp), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = "Sample >= 50; lines show Scotland median") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```


