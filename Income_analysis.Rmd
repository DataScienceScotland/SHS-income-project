---
title: "Assessing the SHS Income Data"
output: 
  bookdown::gitbook:
    split_by: section
    config:
      toc:
        collapse: section
        scroll_highlight: yes
      search: yes
      fontsettings:
        theme: white
        family: sans
      sharing: no
      info: yes
---

```{r setup, include = FALSE}

# Set global chunk options

knitr::opts_chunk$set(
	echo = FALSE,
	fig.asp = 0.5,
	fig.width = 10,
	warning = FALSE
)
# Load packages

library(plyr) # needed for groupwiseMedian function
library(tidyverse)
library(naniar) # for dealing with missing values
library(labelled) # to remove labels from imported data
library(scales) # for comma and percent formats
library(ggrepel) # for non-overlapping chart annotation
library(Hmisc) # for weighted quartiles
library(boot) # needed for groupwiseMedian function
library(readxl)
library(kableExtra) # for making nice-looking tables

# Load functions

source("scr/functions.R")

# Load colour scheme and other strings

source("scr/strings.R")
source("scr/colours.R")

# Load datasets

adult_1819 <- readRDS("output/adult_1819.rds")
househol_1819 <- readRDS("output/househol_1819.rds")
benefits_1819 <- readRDS("output/benefits_1819.rds")
hbai1819 <- readRDS("output/hbai1819.rds")
person18 <- readRDS("output/person18.rds")
hhold18 <- readRDS("output/hhold18.rds")

# Create tidy datasets

source("scr/prepSHSdata.R")
source("scr/prepHBAIdata.R")

# Combine all data

source("scr/prepdata.R")

# Change some theme elements (charts)

theme_update(legend.position = "top",
             legend.title = element_blank(),
             panel.background = element_blank(),
             panel.grid.major.x = element_line(colour = "grey95"),
             panel.grid.minor.x = element_line(colour = "grey95"),
             panel.grid.major.y = element_line(colour = "grey95"),
             axis.ticks = element_blank(),
             text = element_text(size=16))

```

# Results

Here comes the summary 

## Introduction

From previous work done comparing SHS and HBAI data, we expect the average total income to be matching fairly well, even if the individual income components might not match well enough for detailed analysis due to the different remits of the two surveys and resulting methods. Here, we look at how the individual income components differ between the surveys and how that might affect different groups of the population differently.

We compared SHS 2018 income data (the new, broader definition) with HBAI 2018/19 income data. For the HBAI data, we used net income without the top-income adjustment. Except for this, the HBAI income definition we used is the same as that used for official household income and poverty statistics. This definition includes some components that are not available in the SHS, such as child income, and deductions (council tax, pension contributions, maintenance and child support payments, parental contributions to students living away from home, and student loan repayments). Of the deductions, council tax is the only information (indirectly) available in the SHS, and we deducted it from SHS household income. We calculated council tax using the council tax bands and imputing single-person discounts. Some council tax bands were added manually by the SHCS team. Where the council tax band was missing (half of the households in Shetland in the 2018 dataset, but only small numbers in other council areas), we assigned council tax band B, the most common band. 

We also looked at administrative data on benefits to quantify the amount of benefit underreporting in the SHS (and the HBAI).

Note that the income discussed here is net household income after benefits, direct taxes and national insurance contributions, and not taking housing costs into account (= before housing cost). We equivalised all incomes to account for household size, using the modified OECD scale, except when looking at aggregated incomes. 

For the analysis, 95% confidence intervals (C.I.) of the median were calculated using a bootstrapping method. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

In order to make appropriate comparisons across surveys, we recoded some common variables. For example, the definition of a child in the SHS was recoded to match that of the HBAI (i.e. includes 17-19 year-olds living at home, not married, and in full-time non-advanced education). Also, households in the SHS where the highest income householder (which is by definition the household head) is a student, but has earnings income and working hours, were recoded to full- or part-time employee households. This is because of differences in the definition of economic status between the two surveys. In the FRS ILO definition used here, students with jobs would be considered in work, whereas in SHS they would be considered students. After recoding, they will be considered in work in both surveys.

When using hyperlinks to the charts and tables, your browser BACK button will take you back to the previous section. Alternatively, opening the document twice in separate browser windows might make it easier to switch back an forth between text and tables.

## Earnings higher 

Median and mean earnings are higher in the SHS compared to the HBAI, driven by both, slightly higher average employed earnings, and much higher average self-employed earnings (sections \@ref(earnsumm) and \@ref(earneco)).

Median earnings of households where the head is **employed** (both, full- or part-time) match fairly well between surveys, but those where the head is **self-employed** have much higher earnings in the SHS. Checking with the (yet unpublished SHS 2019) dataset shows that this high level of self-employed earnings is consistent across years. This level may be much higher than in the HBAI because the SHS doesn't accept negative earnings responses. However, even when negative earnings in the HBAI were set to zero, the large difference in self-employed earnings persisted. It is possible that it is caused by questionnaire wording and survey time spent on self-employed earnings (section \@ref(earneco)).

Median earnings for some **household types** match fairly well between surveys, for example two adult households with and without children and single adult households, but single parent households slightly less so. Three+ adult households and those with one working-age adult and one pensioner differ considerably and show a wide variability in the HBAI. The latter group appears to have many cases in the HBAI with zero earnings, leading to a median of £0 (section \@ref(earnhhtype)).

Across household **income deciles**, median earnings in the SHS are higher than in the HBAI for higher incomes (deciles 5-10), but lower for deciles 2-4 (where the relative poverty threshold sits), and zero for the bottom decile, same as HBAI earnings. Note that HBAI earnings vary a lot in the lower deciles (section \@ref(earndec)).

Looking at **council areas**, note that HBAI data cannot be meaningfully analysed at a sub-Scotland level, as the weighting regime for the survey doesn’t account for geography within Scotland. However, if we do compare those council areas where household numbers are similar between SHS and HBAI (difference < 50%), median earnings match fairly well across surveys (section \@ref(earncounc)).

Earnings are the largest source of income for economically active households, and therefore earnings patterns determine income patterns for these households. For example, average earnings of households with a self-employed head are much higher in the SHS compared to the HBAI, and we will see later that total income for these households is also considerably higher in the SHS (sections \@ref(earneco) and \@ref(inceco)).

## Benefits lower 

```{r bendiff, echo=FALSE}

bendiff <- tidydata %>%
  filter(type != "total") %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  spread(survey, amount) %>%
  mutate(diff = abs(HBAI - SHS),
         diffcontr = percent(diff/sum(diff), 1)) %>% 
  filter(type == "ben") %>%
  select(diffcontr) %>% pull()

```

Generally, the reported benefit income is lower in the SHS than in the HBAI. The lower benefit income in the SHS explains `r bendiff` of the total income difference between these two surveys (section \@ref(compover)). (Note that when comparing benefit incomes, one should keep in mind that benefits in the HBAI are already underreported (to varying degrees, section \@ref(typover)). The lower benefit income in the SHS is caused by one or a combination of the following: 

* households not reporting they receive a benefit even though they do (= non-reporting)
* households not reporting all the benefits they receive (= non-reporting)
* households reporting a lower benefit amount then they actually receive (= underreporting)

**Working-age households** (defined here as households with no adults above state pension age) receive on average much lower benefits compared to pensioner households (section \@ref(bensumm)). Benefit income of working-age households in the top five income deciles is small and mainly made up of disability benefits, followed by Child Benefit. In the lower income deciles, average benefit income increases, and is made up of disability benefits and Child Benefit, and increasingly (with lower incomes) also with Tax Credits, Housing Benefit and Universal Credit. Benefit income of the bottom income decile is quite low (lower than in deciles 2-4), a common feature of survey-based income data, and probably partly due to various reporting errors. When comparing benefit income for working-age households _across the two surveys_, it appears that disability benefits, Tax Credits, Child Benefit and Universal Credit are lower in the SHS (section \@ref(benincwa)). We will see later that these are underreported in the SHS compared to the HBAI, as are almost all benefits (section \@ref(typover)). The lower income deciles also show large data variability with large uncertainty for both surveys (section \@ref(benincwa)).

**Pensioner households** have on average a much higher benefit income than working-age households due to the State Pension, which is the largest benefit income source and almost universal. The State Pension is followed in importance by disability benefits, Housing Benefit and Pension Credit. Average benefit incomes for pensioner households are quite variable across all income deciles and in both surveys, with SHS central estimates consistently below the HBAI estimates. Median benefit income 95% confidence intervals (C.I.s) don't overlap in the bottom and the 7th income decile, with the SHS estimates far below the HBAI ones. The lower benefit income in the SHS is due to underreporting and/or non-reporting of State Pension and other benefits (section \@ref(benincpn)). In fact, almost all pensioner households in the HBAI report receipt of a benefit, but not so in the SHS: many pensioner households do not report receipt of any benefits, such as the state pension (sections \@ref(bensumm) and \@ref(statepen)). More detail on the income sources of pensioner households is available in section [Pensioners’ incomes too low][Pensioners’ incomes too low].

Median benefit income across the two surveys matches best for those **household types** that don't get many benefits, such as working-age adult households without any children, where the median benefit income is zero in both surveys. On the other hand, median benefit incomes for pensioner households and households with children differ considerably between surveys, with SHS benefit income consistently lower (section \@ref(benhhtype)). For **pensioner couple households**, the difference in median benefit income between the two surveys is partly due to underreporting of the amount of state pension received. This can affect households with two pensioners twice as much compared to those with only one pensioner. In addition, many pensioners in the SHS do not report receiving any state pension at all (section \@ref(statepen)).

For **households with children**, ...

Looking at household **economic status**, median benefit incomes for households where the highest income householder is a full-time employee or self-employed match well between surveys and show a small benefit amount and little variability. There is more variability and discrepancy in median benefit incomes for part-time employee households. All other groups show considerable differences in median benefit incomes, with the SHS amount consistently lower. Median benefit income C.I.s from SHS and HBAI do not overlap at all for retired and disabled households. Reasons for this are largely non-reporting of state pension, and under- and non-reporting of disability benefits (section \@ref(beneco)). Non-reporting of benefits is identified by comparing the number of households who report they receive the benefit. Underreporting of benefits is identified when the median benefit amounts (of those who report them) differ.

Looking across **council areas**, we need to remind ourselves that the HBAI is not designed for sub-Scotland level analysis, and household numbers in each council area are not designed to be accurate. However, removing those council areas with very large (>50%) discrepancies in number of households, and also excluding council areas with too small sample sizes, we're left with less than half of the council areas for comparison across surveys. In these, benefit incomes match reasonably well, but with very wide C.I.s (section \@ref(bencounc)).

Benefits are the largest source of income for economically inactive households, such as pensioner households and those households that are inactive due to disability. Therefore, benefit underreporting hugely influences the total income for these households.

## Main benefit types

```{r bentypes}

bencontr <- tidybens_agg %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount)) %>%
  ungroup() %>%
  group_by(survey) %>%
  gather(key, value, -survey, -type) %>%
  unite(measure, c(key, survey)) %>%
  spread(measure, value) %>%
  mutate(diff = abs(amount_HBAI-amount_SHS),
         HBAI_share = percent(amount_HBAI/sum(amount_HBAI, na.rm = TRUE), 1),
         SHS_share = percent(amount_SHS/sum(amount_SHS, na.rm = TRUE), 1),
         HBAI_capt = percent(amount_HBAI/amount_Admin, 1),
         SHS_capt = percent(amount_SHS/amount_Admin, 1),
         totdiff = sum(diff, na.rm = TRUE),
         diffcontr = ifelse(is.na(diff), NA, percent(diff/totdiff, 1))) %>%
  arrange(desc(diff)) %>%
  filter(!is.na(diffcontr)) 

```

The largest benefit by far is the State Pension, which makes up almost half of all benefit income (`r filter(bencontr, type =="State Pension") %>% select(HBAI_share) %>% pull()` based on HBAI data). This is followed by the combined disability and carers' benefits, followed by Tax Credits, Housing Benefit, Child Benefit, Universal Credit, Pension Credit, and many smaller benefits (section \@ref(typover)).

All of the big benefits except for Housing Benefit are underreported in the SHS compared to the HBAI. (Note that the HBAI also underreports all of the big benefits compared to administrative data.) This could be due to underreporting of the amount received, not reporting a benefit, or a combination of both. Underreporting of State Pension and disability benefits explains most of the benefit income differences between the two surveys (section \@ref(typover)).

The underreporting of (all but one) benefits means that those household types with a large share of their income coming from benefits will be affected more, and show a lower income in the SHS compared to the HBAI. This largely affects households with low or no earnings: pensioners, who receive a large part of their income through the state pension (and other, smaller benefits such as disability and carers' benefits, Pension Credit and Winter Fuel Payment), and households with disabled household members who receive disability and carers' benefits. I expect it also affects other low-earnings households through Tax Credits and Universal Credit. These households will show too low an income in the SHS.

To add more detail, **State Pension** is fairly well captured in the HBAI (covers `r filter(bencontr, type =="State Pension") %>% select(HBAI_capt) %>% pull()` of the aggregated admin data amount), but less so in the SHS (`r filter(bencontr, type =="State Pension") %>% select(SHS_capt) %>% pull()`) (section \@ref(typover)). This discrepancy explains `r filter(bencontr, type =="State Pension") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. It originates in a smaller number of single pensioners in the SHS reporting that they receive the State Pension, even though the average payments are comparable between surveys, and also in too low State Pension amounts in SHS pensioner couple households, maybe because only the state pension of one householder is reported (section \@ref(statepen)).

Combined **disability and carers' benefits** are captured to `r filter(bencontr, type =="Disability") %>% select(HBAI_capt) %>% pull()` in the HBAI, and only to `r filter(bencontr, type =="Disability") %>% select(SHS_capt) %>% pull()` in the SHS. These include Disability Living Allowance, Personal Independence Payment, Attendance Allowance, Employment Support Allowance, Carers' Allowance, Severe Disablement Allowance, and Industrial Injuries Disablement Benefit. I included Carers' Allowance in this list as I expect most carers to live in the same household as the person they care for. The discrepancy between HBAI and SHS disability benefit incomes explains a further `r filter(bencontr, type =="Disability") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. Disability benefits in the SHS are subject to both, underreporting of the amount, and non-reporting of receipt. Underreporting can be identified by comparing the average benefit amounts, and non-reporting can be identified by comparing the numbers of households who report that they receive this benefit (sections \@ref(typover) and \@ref(disimportant)). A large part of the disability benefits goes to pensioner households; however, single adult households are also an important recipient of these benefits (section \@ref(diswho)).

**Tax credits** are also underreported in the SHS compared to the HBAI, explaining a further `r filter(bencontr, type =="Tax Credits") %>% select(diffcontr) %>% pull()` of the benefit income difference between the surveys. A large part of this is part-time employee households underrerporting the amount of Tax Credit they get. Both surveys vastly underreport Tax Credit compared to admin data (sections \@ref(typover) and \@ref(tc)).

**Housing Benefit** is underreported to a similar degree in both surveys, but comparable between surveys and across tenures (sections \@ref(typover) and \@ref(hb)).

**Child Benefit** income in the SHS is only slightly lower than in the HBAI, due to some households with two adults and children not reporting receipt of this benefit (sections \@ref(typover) and \@ref(cb)).

**Universal Credit** and **Pension Credit** are both vastly underreported in the SHS, explaining another `r filter(bencontr, type =="Universal Credit") %>% select(diffcontr) %>% pull()` and `r filter(bencontr, type =="Pension Credit") %>% select(diffcontr) %>% pull()` of the total benefit income difference between HBAI and SHS. For both benefits, the received amounts are underreported. In addition, there are also fewer households in the SHS who report that they receive Pension Credit (sections \@ref(typover), \@ref(uc) and \@ref(pc)).

## Investment income much lower

Investment income is hugely underreported in the SHS compared to the HBAI, even though we are using the HBAI data before top-income adjustments (which would correct top incomes upwards). The massively lower investment income in the SHS is largely due to the fact that only very few households in the SHS report any investment income, even though they report on average higher amounts. Most of investment income is held by retired households, and by working-age two adult households; these are therefore the groups whose total income is affected more by investment income underreporting. Similarly, most of investment income is held by the richest households (section \@ref(investment)).

## Pensioners' incomes too low

**Single pensioner** and **pensioner couple** households get the major part of their income from benefits, which is mainly the State Pension. As the State Pension is underreported in the SHS (compared to the HBAI), household income is underrerported for these household types. The underreporting of State Pension is due to both, underreporting of the amount, and non-reporting of receiving the benefit. Many single pensioners in particular did not report that they received any State Pension at all. As for _pensioner couple_ households, the numbers reporting that they did receive the State Pension was comparable across surveys, but the average amount was lower in the SHS. It is possible that this is because only the State Pension of one person in the couple was considered (section \@ref(pensources)). 

In addition to differences in benefit income (which is mainly the state pension), there are also large differences in occupational pensions and investment income. The difference in investment income is mostly due to non-reporting of investment income in the SHS compared to the HBAI. It should be noted that most of investment income in Scotland goes to retired households, see also section [Investment income much lower][Investment income much lower]. Similarly, fewer people in the SHS report any occupational pension income, although in the aggregate, the SHS occupational pensions income is only slightly below that in the HBAI (sections \@ref(investment) and \@ref(occpen)).

Households with **one working-age adult and one pensioner** get a major part of their income through earnings, followed by occupational pensions and benefits (section \@ref(pensources)). This means that this group is less affected by underreported benefit income, and we will see that the median total income of this group matches better across surveys compared to single pensioner or pensioner couple households (section \@ref(inchhtype)).

And as mentioned before, **Pension Credit**, an income-related benefit for pensioners is subject to both, considerable underreporting of the amount, and non-reporting of receipt for SHS, compared to HBAI. This also contributes in a small part to the benefit income underreporting for pensioners (section \@ref(pc)).

## Income components 

```{r incdiff}

incdiff <- tidydata %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  spread(survey, amount) %>%
  head(1L) %>%
  mutate(diff = percent(1- SHS/HBAI, accuracy = 1)) %>%
  select(diff) %>% 
  pull()

```

Total income aggregated to the whole of Scotland is largely made up of earnings, followed by benefits (which include the state pension) and occupational pensions (section \@ref(compover)). The lower the total income, the less important earnings and the more important benefits become (section \@ref(compdec)).

Overall, SHS total income is `r incdiff` lower than HBAI total income. The differences come mainly from lower benefit and much lower investment income in the SHS, and then also from lower occupational pensions. Income from earnings is higher in the SHS. Other income components are relatively small and therefore contribute less to the overall differences in income (section \@ref(compover)).

We have seen that the lower benefit income mostly affects pensioners (through the state pension) and households with disabled household members (through disability benefits) (sections \@ref(beneco), \@ref(benhhtype), and \@ref(singleadult)).

We have also seen that most of the investment income goes to the wealthiest households. This will affect the income distribution most at the top, and might therefore not matter as much when looking at low income households. However, a large part of investment income goes to retired households, so this could exacerbate the income underreporting of these households even more (sections \@ref(investment) and \@ref(comptype)).

Across the **income distribution**, earnings drive the difference between surveys, as they are the largest component of total income. Average SHS earnings are lower than HBAI earnings at the bottom end of the income distribution, but higher at the top end. (section \@ref(compdist)).

As for **regional underreporting**, this is difficult to ascertain from comparison with HBAI data, because the HBAI's weighting regime doesn't allow sub-Scotland analysis. However, we would expect underreported incomes in those local areas that have a high share of their income coming from benefits, and also in local areas with many pensioners (whose main income source is the State Pension, a benefit).

The six council areas with the highest benefit shares are, according to SHS data, Dumfries & Galloway, Inverclyde, North Ayrshire, East Ayrshire, West Dunbartonshire, and Dundee City (section \@ref(comparea). The eight council areas with the largest proportion of pensioners are Na h-Eileanan Siar, Argyll & Bute, Dumfries & Galloway, South Ayrshire, Scottish Borders, Orkney Islands, Angus, and Perth & Kinross (section \@ref(ageprofile)).

Breaking the country down to urban and rural areas, small towns and other (not large) urban areas have the highest shares of benefit income (section \@ref(comparea)). Remote small towns and remote rural areas on the other hand have the largest proportions of pensioners (section \@ref(ageprofile)).

## Total income overall

Having identified some issues in the measurement of the various _income components_, we will now see how these affect total income.

The income **distributions** in the SHS and the HBAI look largely similar, with the SHS income distribution being slightly wider, and the SHS **median** slightly lower (`r comma(SHSmedian, prefix = "£")` versus `r comma(HBAImedian, prefix = "£")`). Near the relative poverty threshold, the SHS cumulative income curve is higher, meaning more households sit below that threshold in the SHS compared to the HBAI. This means that more people are considered to be in relative poverty when using the SHS dataset compared to the HBAI dataset (section \@ref(incdist)).

The nine income decile points (the thresholds in each dataset that split the populations into ten equal-sized groups) are slightly higher for the SHS for high incomes, level at the sixth decile point, and diverge towards lower incomes, with SHS incomes being markedly lower. This shows that more households in the SHS have lower incomes compared to the HBAI, whereas the high income end of the distribution matches better between surveys. We have seen this is largely caused by benefit underreporting and higher earnings in the SHS (relative to the HBAI). The lower the income, the more important benefit income becomes, and the more affected total income is by benefit underreporting (section \@ref(incdec)).

Median income C.I.s overlap to some degree for all 17 **council areas** where we compared surveys. We excluded those council areas where the HBAI household populations were too far off (> 50% compared to SHS household population). For some council areas, the overlaps are only marginal, such as East Dunbartonshire, Aberdeenshire, Stirling, and Moray, with Aberdeenshire having a  relatively large HBAI sample size. Note also, that none of these areas were noted earlier for particularly high proportions of pensioners or benefit income shares. However, C.I.s for all council areas and for both surveys are fairly wide, showing much income variation within each council area (section \@ref(inccounc)).

Median incomes match fairly well for **urban** and accessible rural areas. Median incomes in remote areas match slightly less well, but also have fairly wide C.I.s (section \@ref(incarea)).

Median incomes of **working-age adults** and **children** match well, but **pensioners**' incomes are much lower in the SHS, and C.I.s do not overlap. We saw that this is largely due to underreporting of the State Pension, as well as occupational pensions and investment income (sections \@ref(incage) and \@ref(pensources)).

Incomes for most **household types** match well, except, again, for pensioners, whose income is much lower in the SHS. Incomes of households with 3 or more adults (and no children) have very wide C.I.s, indicating large variation of incomes in this group. Single adult incomes match surprisingly well, considering how much benefit income is underreported for this group. However, earnings in this group are higher in the SHS than the HBAI and appear to balance out the benefit underreporting (section \@ref(inchhtype)).

Incomes of households where the household head (the highest income householder) is a **full- or part-time employee** match fairly well, which is no surprise as income from employed earnings also matches fairly well. As expected, incomes of the **retired** don't match well, similarly to pensioners' incomes in the age group and household type breakdowns. Incomes of households with a **disabled** household head also don't match too well, due to undereporting of disability benefits, which are the main income source of these households (section \@ref(inceco)).

Households where the head is **self-employed** had very variable incomes and a higher median in the SHS, driven by much higher earnings (section \@ref(earneco)). This is consistent with the (yet unpublished and therefore not included) SHS 2019 data, so not a blip. On the other hand, benefit income is lower, but has much less of an impact as it is on average much less important than earnings (section \@ref(beneco)). Reasons for the higher earnings of the self-employed in the SHS could include that the SHS my not fully account for self-employed losses, or not in the same way as the HBAI. For example, the SHS doesn't accept negative earnings responses. Also, the definitions of self-employment may differ between surveys. Note that households where the head is self-employed make up only 7% of all households (according to SHS 2018), so maybe this issue isn't very important.

## Open questions

- How well do housing costs match? There are some inherent differences between surveys of what's included as a housing cost. The main difference is for home owners with a mortgage: While the HBAI considers only the mortgage interest as a housing cost, the SHS also includes mortgage capital repayments. Furthermore, the HBAI also includes rent, water and sewerage charges, and (structural) home insurance. In the SHS, housing costs include rent and mortgage payments.

- In the analysis here, we didn't use the usual HBAI BHC income variable, but income without top-income adjustments. The reason for this is that the top-income adjusted income figures are only available for gross income, but not net income. The effect on the median is small. The HBAI median without top-income adjustment is `r comma(HBAImedian, prefix = "£", accuracy = 1)`, whereas the top-income adjusted median is £517. We expect higher incomes to be affected more.

- Self-employed earnings are much higher in the SHS compared to the HBAI. Also, the SHS doesn't allow negative earnings responses. The difference in self-employed earnings between surveys is probably due to the questionnaire wording and interview time spent on getting this information.

- can we calculate better confidence intervals for the HBAI data using the resamples dataset that DWP provide?

- how important is children's income? SHS doesn't collect information on this. Ipsos Mori report showed it made up 1% of single parents' income

- SHS doesn't ask about children's benefits such as child DLA. However, benefit income by household type doesn't look particularly bad for households with children. Might need to look into this further for any breakdowns of child poverty by disability.

- Many pensioners in the SHS do not report that they receive state pension. Is this due to the question wording? Maybe model state pension instead of imputing it?

- Should we include recommendations for SHS questionnaire or editing changes? I.e. imputing state pensions, wording change for disability benefits to harmonise with FRS, etc.


# Charts and tables

This part includes all tables and charts produced for the analysis. The survey data comes from the SHS 2018 and the HBAI 2018/19; and the administrative benefit data from StatXplore and the Scottish Government.

Tables and charts are subject to **suppressed data** where sample sizes are too small. For the HBAI, at least 50 cases in the sample are required to report on mean, median and total amounts, and at least 100 cases are required to report on number of individuals or households. Suppressed data in the tables is marked "..".

Note that the 95% **confidence intervals** (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

Note that the FRS is not designed to provide **sub-Scotland disaggregation**. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

**Adults** refer to working-age adults without children unless otherwise stated. **Pensioners** refer to people above state-pension age. **Children** refer to dependent children.

The **household head** is the person in the household with the highest income, or, where incomes are equal, the older person.

## Earnings {#earnings}

### Summary stats {#earnsumm}

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households (including all households):

```{r median_earnings}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000)) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

```

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings (excluding households with no earnings):

```{r median_earnings2}

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000)) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

```


### Earnings distribution {#earndist}

```{r earn_distributions}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  mutate(weight = ppwgt/sum(ppwgt)) %>%
  ggplot(aes(x = amount, 
             weight = weight, 
             colour = survey, fill = survey )) +
  geom_density(size = 1, alpha = 0.5, bw = 0.02) +
  scale_x_log10(labels = comma_format(prefix = "£")) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Net equivalised household earnings density distributions",
       subtitle = "Note log x scale",
       x = "Weekly equivalised net household earnings",
       y = NULL) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank(),
         panel.grid.minor.x = element_blank())

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey) %>%
  ggplot(aes(x = amount, weight = ppwgt, colour = survey, fill = survey )) +
  coord_cartesian(xlim = c(0, 1000)) +
  stat_ecdf(geom = "step", size = 1, alpha = 0.5) +
  scale_x_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000)) +
  scale_y_continuous(labels = percent_format()) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Cumulative net equivalised household earnings distributions",
       subtitle = "Note linear x scale",
       x = "Weekly equivalised net household earnings",
       y = "Proportion of people") +
   theme(panel.grid.minor.x = element_blank(),
         axis.text.y = element_text())

```

### by economic status {#earneco}

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households by economic status of household head (including all households):

```{r earnings_inc}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = fct_reorder2(HIHemp, survey, desc(total)),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  arrange(desc(HIHemp)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

```{r earnings_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI", 
                              HIHemp %in% empstatnames[1:3]) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS", 
                              HIHemp %in% empstatnames[1:3]) %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, survey, desc(Median))) %>%
  filter(n >= 50) %>%
  ggplot() +
  geom_point(aes(x = HIHemp, 
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median equivalised household earnings',
         subtitle = "Includes all households; lines show overall medians") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) +
  theme(panel.grid.major.y = element_blank())

```

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings by economic status of household head (excluding households with no earnings):

```{r earnings_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = fct_reorder2(HIHemp, survey, desc(total)),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  arrange(desc(HIHemp)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### by household type {#earnhhtype}

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households by household type (all households):
```{r earnings_hhtype_inc}

tidydata %>%
  filter(type == "earn") %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(hhtype) %>%
  mutate(median =  ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  knitr::kable(align = "lrrrrrr") %>%
  kable_styling("striped")

```

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

Adults refer to working-age adults without children unless otherwise stated. Pensioners refer to people above state-pension age. Children refer to dependent children.

```{r earnings_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, desc(Median))) %>%
  filter(n >= 50) %>%
  ggplot() +
  geom_point(aes(x = hhtype, 
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings',
         subtitle = str_wrap("Includes households with and without earnings; sample >= 50; lines show overall medians", 75)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-200, 800)) 

```

Weekly net equivalised median and mean household earnings, aggregated weekly earnings, and number of households reporting any earnings by household type (excluding households with no earnings):
```{r earnings_hhtype_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, 
                                  probs = 0.5, 
                                  weights = ppwgt),
            mean = wtd.mean(amount, 
                            weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(hhtype) %>%
  mutate(median =  ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£", accuracy = 1)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£", accuracy = 1)),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, accuracy = 10000))) %>%
  knitr::kable(align = "lrrrrrr") %>%
  kable_styling("striped")

```

### by income decile {#earndec}

Note that the 95% confidence intervals (C.I.s) of the median are based on a bootstrap methodology. For the HBAI, the boostrapped C.I.s do not account for the complex survey design. They are therefore only illustrative and may be wider. The C.I.s calculated for the SHS take into account the survey design (stratification by council areas).

```{r earnings_deciles}

# Earnings by hhld income decile

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)
# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "earn", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         decile = factor(decile)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = decile, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = decile,
                   xend = decile,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings by household income decile',
         subtitle = 'Includes all households') +
  scale_y_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000, 1200)) +
  coord_flip(ylim = c(-25, 1175)) 

```

### by council area {#earncounc}

***

Note that the FRS is not designed to provide sub-Scotland disaggregation. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis further below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

```{r hhlds_council}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey, council) %>%
  summarise(households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  filter(sample >= 50) %>%
  select(-sample) %>%
  spread(survey, households) %>%
  filter(!is.na(HBAI)) %>%
  mutate(diff = (HBAI - SHS)/SHS,
         diffsize = ifelse(abs(diff) < 0.5, "HBAI", "SHS"),
         council = fct_reorder(council, diff)) %>%
  ggplot(aes(x = council, y = diff, fill = diffsize)) +
  geom_col(position = "dodge") +
  annotate("text", x = 18, y = 0.6, 
           label = "Difference > 50%",
           hjust = 0, colour = cols_survey[2],
           fontface = "bold") +
  scale_y_continuous(labels = percent_format(1)) +
  scale_fill_manual(values = cols_survey, guide = FALSE) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Difference in SHS and HBAI household populations by council area",
       subtitle = str_wrap("Positive values = HBAI population higher than SHS population; excludes councils with < 50 cases", 80)) 



```

***

Weekly net equivalised household earnings by council area (including all households, but excluding council areas where population differences are > 50%):
```{r earnings_council_inc}

tidydata %>%
  filter(type == "earn",
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%

  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")


```

Note that the FRS is not designed to provide sub-Scotland disaggregation. The Scottish sample in the FRS is stratified into six regions, but the FRS _grossing regime_ doesn't look below Scotland-level. For the council area analysis further below, we exclude those council areas where the household populations differ by more than 50% between FRS/HBAI and SHS.

```{r earnings_council_ci}

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "earn", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "earn", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(council = fct_reorder2(council, survey, desc(Median))) %>%
  ggplot() +
  geom_point(aes(x = council, y = Median, colour = survey), 
             size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
  geom_hline(yintercept = medianearnings["HBAI"], 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = medianearnings["SHS"], 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household earnings by council area',
         subtitle = str_wrap('Includes all households, councils with >= 50 cases, and councils where household population is off by < 50%; lines show Scotland medians', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-100, 900))

```

Weekly net equivalised household earnings by council area (excludes households with zero earnings, and council areas where population differences are > 50%):
```{r earnings_council_exc}

tidydata %>%
  filter(type == "earn",
         amount != 0,
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%

  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

## Benefit income {#benefits}

### Summary stats {#bensumm}

Weekly benefit household income, equivalised median and mean, aggregated total, and number of households (including all households):
```{r median_benefits_inc}

all <- tidydata %>%
  filter(type == "ben") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "All") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households") %>%
  select(group, everything())

pns <- tidydata %>%
  filter(type == "ben",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Pensioner households") %>%
  select(group, everything()) 

rbind(all, waa, pns) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

Weekly benefit household income, equivalised median and mean, aggregated total, and number of households receiving benefits (excludes households with no benefit income):
```{r median_benefits_exc}

all <- tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "All") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "ben",
         pnwgt == 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Working-age households") %>%
  select(group, everything())

pns <- tidydata %>%
  filter(type == "ben",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*equ*hhwgt),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(median =  comma(median, prefix = "£", accuracy = 1),
         mean = comma(mean, prefix = "£", accuracy = 1),
         total = comma(total, scale = 1E-6, prefix = "£", suffix = " million"),
         households = comma(households, accuracy = 10000),
         group = "Pensioner households") %>%
  select(group, everything()) 

rbind(all, waa, pns) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### by income deciles - working-age households {#benincwa}

```{r benefits_deciles_waa}

# Benefits by hhld income decile

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI",
                              pnwgt == 0) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "SHS",
                              pnwgt == 0) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         decile = factor(decile)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = decile, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = decile,
                   xend = decile,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = str_wrap('Working-age adults - weekly median equivalised benefit income by household income decile', 70),
         subtitle = str_wrap('Includes households with and without benefit income; excludes households with pensioners', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-100, 400))

```

We combined the following disability and carers' benefits into "Disability":

- Personal Independence Payment
- Disability Living Allowance
- Employment and Support Allowance
- Attendance Allowance
- Carer's Allowance
- Incapacity Benefit
- Severe Disablement Allowance
- Industrial Injuries Disablement Benefit

I included Carer’s Allowance in this list as I expect most carers to live in the same household as the person they care for.

```{r benefits_types_decile_waa}

mainbens <- tidybens_agg %>%
  filter(survey == "HBAI") %>%
  mutate(type = fct_collapse(type, Disability = str_trunc(disbens, 30)),
         type = fct_reorder(type, desc(amount))) %>%
  group_by(type) %>%
  summarise(amount = sum(amount)) %>%
  head(length(cols_bens)) %>%
  select(type) %>% 
  pull()

names(cols_bens) <- mainbens

tidybens %>%
  filter(pnwgt == 0) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  count(survey, decile, type, wt = hhwgt*amount*equ, name = "total") %>%
  group_by(survey, decile) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(decile = factor(decile),
         type = fct_reorder(type, total)) %>%
  ggplot(aes(x = decile, y = total, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "What are the main benefits in each income decile?", 
       subtitle = str_wrap("Aggregated weekly benefit income of the five most common benefits in each income decile; excludes households with pensioners", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(scale = 1E-6, suffix = " million")) +
  theme(legend.position = "right",
        panel.grid.major.x = element_blank())

```

### by income deciles - pensioner households {#benincpn}

```{r benefits_deciles_pn}

# Benefits by hhld income decile

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI",
                              pnwgt > 0) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "decile",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "SHS",
                              pnwgt > 0) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         decile = factor(decile)) %>%
  filter(!is.na(Median)) %>% 
  ggplot() +
  geom_point(aes(x = decile, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = decile,
                   xend = decile,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Pensioner hhlds - weekly median benefit income by household income decile',
         subtitle = str_wrap('Includes households with pensioners only; includes households with and without benefit income', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-100, 400))

```

We combined the following disability and carers' benefits into "Disability":

- Personal Independence Payment
- Disability Living Allowance
- Employment and Support Allowance
- Attendance Allowance
- Carer's Allowance
- Incapacity Benefit
- Severe Disablement Allowance
- Industrial Injuries Disablement Benefit

```{r benefits_types_decile_pn}

tidybens %>%
  filter(pnwgt > 0) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  count(survey, decile, type, wt = hhwgt*amount*equ, name = "total") %>%
  group_by(survey, decile) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(decile = factor(decile),
         type = fct_reorder(type, total)) %>%
  ggplot(aes(x = decile, y = total, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "What are the main benefits in each income decile?", 
       subtitle = str_wrap("Aggregated weekly benefit income of the five most common benefits in each income decile; includes pensioner households only", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(scale = 1E-6, suffix = " million")) +
  theme(legend.position = "right",
        panel.grid.major.x = element_blank())

```


### by household type {#benhhtype}

Weekly household benefit income by household type, equivalised median and mean, aggregated total, and number of households  (including all households):
```{r benefits_hhtype_inc}

tidydata %>%
  filter(type == "ben") %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = sum(n)) %>%
  ungroup() %>%
  mutate(total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         hhtype = factor(hhtype, levels = hhtypenames),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£"))) %>%
  arrange(hhtype, survey) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped") 

```


Note that this chart excludes the Two adults with children group due to too many zero values in the HBAI sample for this group.
```{r bens_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI",
                              hhtype != "Two adults with children") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata,
                              type == "ben",
                              survey == "SHS",
                              hhtype != "Two adults with children") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, Median)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = fct_rev(hhtype), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower,
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Equivalised weekly median household benefit income',
         subtitle = str_wrap("Includes households with and without benefit income; sample >= 50; excludes household type Two Adults with Children", 75)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-100, 400))

```

Weekly household benefit income by household type, equivalised median and mean, aggregated total, and number of households with benefit income (excludes households with no benefit income):
```{r benefits_hhtype_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = sum(n)) %>%
  ungroup() %>%
  mutate(total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         hhtype = factor(hhtype, levels = hhtypenames),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£"))) %>%
  arrange(hhtype, survey) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped") 

```

### by economic status {#beneco}

Weekly household benefit income by economic status of the household head, equivalised median and mean, aggregated total, and number of households (including all households):
```{r benefits_eco_inc}

tidydata %>%
  filter(type == "ben") %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(HIHemp = factor(HIHemp, levels = empstatnames),
         total = ifelse(survey == "HBAI" & sample < 100, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 50, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 100, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 100, "..", comma(median, prefix = "£"))) %>%
  arrange(HIHemp, survey) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

```{r bens_eco_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "ben", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, survey, Median)) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = fct_rev(HIHemp), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Equivalised weekly median household benefit income',
         subtitle = "Includes households with and without benefit income; sample >= 50") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-90, 410)) 

```

Weekly household benefit income by economic status of the household head, equivalised median and mean, aggregated total, and number of households with benefit income (excludes households with no benefit income):
```{r benefits_eco_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(HIHemp = factor(HIHemp, levels = empstatnames),
         total = ifelse(survey == "HBAI" & sample < 100, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 50, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 100, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 100, "..", comma(median, prefix = "£"))) %>%
  arrange(HIHemp, survey) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### by council area {#bencounc}

Weekly benefit household income by council area, equivalised median and mean, aggegrated total and number of households (including all households; but excludes council areas with < 50 cases, and council areas where population differences between surveys are > 50%):
```{r benefits_council_inc}

tidydata %>%
  filter(type == "ben",
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..",  comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped") 


```

```{r benefits_council_ci}

# Get councils with a large enough sample size (households with earnings > 0)

councilsn50 <- filter(tidydata, 
       type == "ben",
       amount != 0,
       survey == "HBAI") %>%
  group_by(council) %>%
  count() %>%
  filter(n >= 50) %>%
  select(council) %>% pull()

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "ben", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "ben", 
                              council %in% councilsn50,
                              council %in% popokcouncils,
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(Median = ifelse(n < 50, NA, Median),
         Normal.lower = ifelse(n < 50, NA, Normal.lower),
         Normal.upper = ifelse(n < 50, NA, Normal.upper),
         council = factor(council),
         council = fct_reorder2(council, survey, desc(Median))) %>%
  filter(!is.na(Median)) %>%
  ggplot() +
  geom_point(aes(x = council, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median benefit household income by council area',
         subtitle = str_wrap('Includes households with and without benefit income; councils with >= 50 cases; councils where household populations are off by < 50%', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(-100, 400))

```

Weekly benefit household income by council area, equivalised median and mean, aggegrated total and number of households with benefit income (excludes households with no benefit income, council areas with < 50 cases, and council areas where population differences between surveys are > 50%):
```{r benefits_council_exc}

tidydata %>%
  filter(type == "ben",
         amount != 0,
         council %in% popokcouncils) %>%
  group_by(survey, council) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  arrange(council, survey) %>%
  mutate(median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1 , prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..",  comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped") 

```

## Types of benefits {#types}

### Overview over all benefits {#typover}

Aggregated weekly benefit amounts, and how well the actual amounts (based on admin data) is captured by each survey:
```{r ben_types}

tidybens_agg %>%
  group_by(survey) %>%
  summarise(amount = sum(amount),
            type = "total") %>%
  spread(survey, amount) %>%
  mutate(capt_HBAI = percent(HBAI/Admin, 1),
         capt_SHS = percent(SHS/Admin, 1)) %>%
  mutate_at(c("Admin", "HBAI", "SHS"), comma_format(scale = 1E-6, accuracy = 1, prefix = "£", suffix = " million")) %>%
  knitr::kable(align = "lrrrrrrrr", col.names = c("", "Admin", "HBAI", "SHS", "HBAI", "SHS")) %>%
  add_header_above(c(" " = 1, "Aggregated amount" = 3, "Captured admin data level" = 2))

```

Aggregated weekly benefit amounts for each of the largest twelve benefits, how much each benefit contributes to total benefit income (in the adming data and for each survey), how fully the _actual amounts_ (based on admin data) are captured by each survey, and how much each benefit contributes to the total benefit income difference between the two surveys:
```{r ben_types_detailed}

tidybens_agg %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(totshare = amount/sum(amount)) %>%
  gather(key, value, -survey, -type) %>%
  unite(measure, c(key, survey)) %>%
  spread(measure, value) %>%
  arrange(desc(amount_Admin)) %>%
  mutate(capt_HBAI = percent(amount_HBAI/amount_Admin, 1),
         capt_SHS = percent(amount_SHS/amount_Admin, 1),
         diff = abs(amount_HBAI-amount_SHS),
         totdiff = sum(diff, na.rm = TRUE),
         diffcontr = percent(diff/totdiff, 1)) %>%
  select(-totdiff, -diff) %>%
  mutate_at(c("amount_Admin", "amount_HBAI", "amount_SHS"), comma_format(scale = 1E-6, accuracy = 1, prefix = "£", suffix = " million")) %>%
  mutate_at(c("totshare_Admin", "totshare_HBAI", "totshare_SHS"), percent_format(1)) %>%
  head(12L) %>%
  knitr::kable(align = "lrrrrrrrrr", col.names = c("", "Admin", "HBAI", "SHS", "Admin", "HBAI", "SHS", "HBAI", "SHS", " ")) %>%
  add_header_above(c(" " = 1, "Aggregated amount" = 3, "Share of total benefit income" = 3, "Captured admin data level" = 2, "Contribution to HBAI/SHS difference" = 1))

```

```{r ben_types_chart, fig.asp = 0.8}
tidybens_agg %>%
  filter(type %in% tail(levels(type), 14L)) %>%
  mutate(type = as.character(type),
         type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount)) %>%
  ggplot(aes(x = fct_reorder2(type, desc(survey), desc(amount)), y = amount, fill = survey)) +
  geom_col(position = "dodge") +
  geom_text(aes(y = amount + 8E5,
                label = str_c("£", comma(amount, scale = 1E-6), " m"), colour = survey),
            position =  position_dodge(width = 1),
            hjust = 0) +
  scale_fill_manual(values = cols_survey) +
  scale_colour_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(scale = 1E-6, suffix = " million", prefix = "£")) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Aggregated weekly benefit income of the largest benefits") +
  theme(panel.grid.major.y = element_blank())

```

### State Pension {#typstatepen}

See [Pensioners' incomes][Pensioners' incomes]

### Disability benefits - which are the most important? {#disimportant}

Disability benefits include:

- Employment and Support Allowance
- Disability Living Allowance
- Personal Independence Payment
- Attendance Allowance
- Carer's Allowance
- Severe Disablement Allowance
- Industrial Injuries Disablement Benefit
- Incapacity Benefit

Further below, these benefits are combined into a single "Disability" category. I also included Carer’s Allowance in this list as I expect most carers to live in the same household as the person they care for.

Individual disability benefits, aggregated weekly total, equivalised weekly median and mean, and numbers of households where someone received this benefit (excludes households who didn't report receiving this benefit):
```{r dis_benefits}

tidybens %>%
  filter(type %in% str_trunc(disbens, 30),
         amount != 0) %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(type = factor(type),
         type = fct_reorder(type, total),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         households = ifelse(sample < 100 & survey == "HBAI", "..", comma(households, 10000))) %>%
  arrange(desc(type)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Disability benefits - who gets them? {#diswho}

Combined disability and carer's benefits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of a disability/carer's benefit:
```{r disability_hhtype}

tidybens %>%
  filter(type %in% disbens,
         survey != "Admin",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, total),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, prefix = "£")),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000))) %>%
  arrange(hhtype) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")
 
```

### Tax credits {#tc}

Tax credits, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of tax credits by economic status of household head:
```{r tax_credits}

tidybens %>%
  filter(type == "Tax Credits",
         amount != 0,
         HIHemp %in% c("Part-time Employee", "Full-time Employee", "Self-Employed")) %>%
  group_by(survey, HIHemp) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(HIHemp) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Housing Benefit {#hb}

Housing benefit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of housing benefit by tenure:
```{r housing_benefit}

tidybens %>%
  filter(type == "Housing Benefit",
         amount != 0) %>%
  group_by(survey, tenure) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(tenure = factor(tenure),
         tenure = fct_reorder2(tenure, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(tenure)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Child Benefit {#cb}

Child benefit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of child benefit by household type (excludes households without any children and those not reporting any child benefit):
```{r child_benefit}

tidybens %>%
  filter(type == "Child Benefit",
         amount != 0,
         chwgt > 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Universal credit {#uc}

Universal Credit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of universal credit (excludes households with no universal credit):
```{r universal_credit}

tidybens %>%
  filter(type == "Universal Credit",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Pension credit {#pc}

Pension Credit, aggregated weekly amount, equivalised weekly mean and median, and number of households in receipt of pension credit (excludes households with no pension credit):
```{r pension_credit}

tidybens %>%
  filter(type == "Pension Credit",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

## Single working-age adult benefit income {#singleadult}

Weekly benefit income (from all benefits) for single working-age adult households, aggregated total, equivalised median and mean, and number of single adult households (includes all households):
```{r single_adult_bens_inc}

tidydata %>%
  filter(hhtype == "Single adult",
         type == "ben") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

```

Weekly benefit income (from all benefits) for single working-age adult households, aggregated total, equivalised median and mean, and number of single adult households receiving benefits (excludes households with no benefit income):
```{r single_adult_bens_exc}

tidydata %>%
  filter(hhtype == "Single adult",
         type == "ben",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  filter(sample > 30) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

```

Weekly benefit income for single working-age adult households from the largest benefits - aggregated total, equivalised median and mean, and number of single adult households receiving each benefit:
```{r single_adult_bens_types}

tidybens %>%
  mutate(type = ifelse(type %in% str_trunc(disbens, 30), "Disability", type)) %>%
  filter(hhtype == "Single adult",
         amount != 0) %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(type = factor(type),
         type = fct_reorder2(type, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  filter(sample > 30) %>%
  arrange(desc(type)) %>%
  head(6L) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

## Investment income {#investment}

Weekly investment income, equivalised mean and median, aggregated total, and number of households with investment income (excludes households with no investment income):
```{r investment_inc}

tidydata %>%
  filter(type == "inv") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrr") %>%
  kable_styling("striped")

```

Weekly investment income, equivalised mean and median, aggregated total, and number of households with investment income (excludes households with no investment income):
```{r investment_exc}

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  knitr::kable(align = "llrrrr") %>%
  kable_styling("striped")

```

Who has income from investments?

```{r investment_eco}

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, HIHemp) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         HIHemp = fct_reorder(HIHemp, share)) %>%
  ggplot(aes(x = HIHemp, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across household types") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         hhtype = fct_reorder(hhtype, share)) %>%
  ggplot(aes(x = hhtype, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across household types") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

tidydata %>%
  filter(type == "inv",
         amount != 0) %>%
  group_by(survey, decile) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            mean = wtd.mean(amount, weights = hhwgt),
            median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            sample = n(),
            people = sum(ppwgt)) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Share of aggregated investment income across income deciles") +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

## Pensioners' incomes {#pensioners}

### Pensioners' income sources {#pensources}

The charts and table below show different aspects of pensioners' incomes for each of the three household types containing pensioners.

The total aggregated weekly income and main income sources (earnings, benefits, occupational pensions, investments). This chart shows the total extent of income under- and overreporting, and which income components contribute the most to the differences in total income.
```{r pensioners_sources_a}

tidydata %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner"),
         type %in% c("total", "earn", "ben", "occ", "inv")) %>%
  group_by(survey, type, hhtype) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>% 
  filter(sample >=50) %>%
  ggplot(aes(x = type, y = tot, fill = survey)) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(scale = 1E-6,
                                           prefix = "£", 
                                           suffix = " m")) +
  facet_wrap(vars(hhtype)) +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Aggregated weekly income and main income sources for pensioner households", 70)) +
   theme(panel.grid.major.x = element_blank())

```

The mean equivalised total income and income sources (includes all pensioner households). This chart shows differences in the average reported amount of each income type.
```{r pensiones_sources_b}

tidydata %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner"),
         type %in% c("total", "earn", "ben", "occ", "inv")) %>%
  group_by(survey, type, hhtype) %>%
  summarise(mean = wtd.mean(amount, weights = hhwgt, na.rm = TRUE),
            sample = n()) %>% 
  filter(sample >= 50) %>%
  ggplot(aes(x = type, y = mean, fill = survey)) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = comma_format(prefix = "£")) +
  facet_wrap(vars(hhtype)) +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Mean equivalised weekly income and main income sources for pensioner households", 70)) +
   theme(panel.grid.major.x = element_blank())
```

The number of pensioner households who report they receive each type of income. Income types based on fewer than 100 cases in the sample are excluded. This table shows how many more or less households report that they receive certain income types for each survey, and can therefore flag non-reporting of a particular income type. 
```{r pensioners_sources_c}

tidydata %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner"),
         amount != 0,
         type %in% c("earn", "ben", "occ", "inv")) %>%
  group_by(survey, type, hhtype) %>%
  summarise(households = sum(hhwgt),
            sample = n()) %>% 
  filter(sample >= 100) %>%
  select(hhtype, type, households, survey) %>%
  spread(survey, households) %>%
  mutate(HBAI = ifelse(is.na(HBAI), "..", comma(HBAI, 10000)),
         SHS = ifelse(is.na(SHS), "..", comma(SHS, 10000))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrr") %>%
  kable_styling("striped")

```

### Pensioners' benefit types {#penbens}

```{r benefits_types_pntype}

tidybens %>%
  filter(hhtype %in% c("Single pensioner", "Two pensioners", "One adult, one pensioner")) %>%
  mutate(type = factor(type),
         type = fct_collapse(type, Disability = str_trunc(disbens, 30))) %>%
  group_by(survey, hhtype, type) %>%
  summarise(total = sum(hhwgt*amount*equ)) %>%
  ungroup() %>%
  group_by(survey, hhtype) %>%
  filter(type %in% type[order(-total)[1:5]]) %>%
  ungroup() %>%
  mutate(type = fct_reorder(type, total)) %>%
  ggplot(aes(x = hhtype, y = total, fill = type)) +
  geom_col() +
  scale_fill_manual(values = cols_bens) +
  facet_wrap(~survey, nrow = 2) +
  labs(title = "What are the main benefits for each type of pensioner household?", 
       subtitle = str_wrap("Aggregated weekly benefit income of the five most common benefits in each household type", 80),
       x = NULL, y = NULL) +
  scale_y_continuous(labels = comma_format(scale = 1E-6, suffix = " million")) +
  theme(legend.position = "right") +
   theme(panel.grid.major.x = element_blank())

```

### State pension {#statepen}

State Pension - aggregate weekly amount, equivalised weekly median and mean, and number of pensioner households (includes all pensioner households):
```{r state_pension_hhtype_inc}

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         hhtype = "All pensioner households") %>%
  select(survey, hhtype, everything()) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

State Pension - aggregate weekly amount, equivalised weekly median and mean, and number of pensioner households in receipt of State Pension (excluding households with no state pension):
```{r state_pension_hhtype_exc}

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         hhtype = "All pensioner households") %>%
  select(survey, hhtype, everything()) %>%
  knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")

tidybens %>%
  filter(type == "State Pension",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey, hhtype) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = fct_reorder2(hhtype, survey, desc(total)),
         households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
            mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
            median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
            total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  arrange(desc(hhtype)) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

### Occupational pensions {#occpen}

Occupational Pensions - aggregate weekly amount, equivalised weekly median and mean, and number of households (includes all households):
```{r occ_pension_inc}

pns <- tidydata %>%
  filter(type == "occ",
         pnwgt > 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Pensioner households") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "occ",
         pnwgt == 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Working-age households") %>%
  select(group, everything())

all <- tidydata %>%
  filter(type == "occ") %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "All households") %>%
  select(group, everything())

rbind(all, pns, waa) %>%
  knitr::kable(align = "lllrrrrr") %>%
  kable_styling("striped")

```

```{r occ_pen_eco}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, HIHemp) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         HIHemp = fct_reorder(HIHemp, share)) %>%
  ggplot(aes(x = HIHemp, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income across household types", 80)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

```{r occ_pen_hhtype}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, hhtype) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         hhtype = fct_reorder(hhtype, share)) %>%
  ggplot(aes(x = hhtype, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income by economic status of household head", 75)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

```{r occ_pen_dec}

tidydata %>%
  filter(type == "occ") %>%
  group_by(survey, decile) %>%
  summarise(tot = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  group_by(survey) %>%
  mutate(share = tot/sum(tot),
         decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = share, fill = survey)) +
  geom_col(position = "dodge") +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(label = percent_format(1)) +
  labs(x = NULL, y = NULL,
       title = "Who gets occupational pensions?",
       subtitle = str_wrap("Share of aggregated occupational pensions income across household income deciles", 80)) +
  coord_flip() +
   theme(panel.grid.major.y = element_blank())

```

Occupational Pensions - aggregate weekly amount, equivalised weekly median and mean, and number of households in receipt of occupational pensions (excluding households with no occupational pensions):
```{r occ_pension_exc}

pns <- tidydata %>%
  filter(type == "occ",
         pnwgt > 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Pensioner households") %>%
  select(group, everything())

waa <- tidydata %>%
  filter(type == "occ",
         pnwgt == 0,
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "Working-age households") %>%
  select(group, everything())

all <- tidydata %>%
  filter(type == "occ",
         amount != 0) %>%
  group_by(survey) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million")),
         group = "All households") %>%
  select(group, everything())

rbind(all, pns, waa) %>%
  knitr::kable(align = "lllrrrrr") %>%
  kable_styling("striped")

```

## Self-employed's incomes {#selfemp}

Total weekly income and income sources of households with a self-employed household head - equivalised mean and median, aggregated total, and number of households (all households):
```{r selfemployed_sources}

tidydata %>%
  filter(HIHemp == "Self-Employed") %>%
  group_by(survey, type) %>%
  summarise(median = wtd.quantile(amount, probs = 0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt),
            total = sum(amount*hhwgt*equ),
            households = sum(hhwgt),
            sample = n()) %>%
  mutate(households = ifelse(survey == "HBAI" & sample < 100 | survey == "SHS" & sample < 30, "..", comma(households, 10000)),
         mean = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(mean, 1, prefix = "£")),
         median = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(median, 1, prefix = "£")),
         total = ifelse(survey == "HBAI" & sample < 50 | survey == "SHS" & sample < 30, "..", comma(total, scale = 1E-6, prefix = "£", suffix = " million"))) %>%
  #filter(sample >=30 ) %>%
  arrange(type) %>%
  knitr::kable(align = "llrrrrr") %>%
  kable_styling("striped")

```

## Income components {#components}

### Overview over income components {#compover}

In each survey, how much does each income source contribute to total income?

```{r components}

tidydata %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  ggplot(aes(x = type,
           y = amount,
           fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = ifelse(type == "ded", amount + 140000000, amount + 70000000),
                label = comma(amount, scale = 1E-6),
                colour = survey),
            show.legend = FALSE,
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_colour_manual(values = cols_survey) +
  scale_y_continuous(label = comma_format(scale = 1E-9, 
                                          prefix = "£", 
                                          suffix = " billion", 
                                          accuracy = 0.1)) +
  labs(title = str_wrap("Aggregated weekly income - total income and income sources", 70), x = NULL, y = NULL) +
   theme(panel.grid.major.x = element_blank())

```

How much does each income component contribute to the difference in total income? The income components are earnings, benefits, occupational pensions, investment income, other, private benefits, and deductions.

Aggregate weekly amount in each survey, the absolute difference between the surveys for each income component, and how much each component contributes to the difference in total aggregated income. Note that these contributions are based on absolute differences and are therefore all positive percentages. There are of course other ways to illustrative the relative importance of each income component:
```{r aggregate_components}

tidydata %>%
  group_by(survey, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  spread(survey, amount) %>%
  mutate(diff = HBAI - SHS,
         absdiff = abs(diff),
         totdiff = sum(absdiff[2:8]),
         diffcontr = ifelse(type == "total", 1, abs(diff)/totdiff)) %>%
  mutate(HBAI = comma(HBAI, scale = 1E-6, prefix = "£", suffix = " million", accuracy = 1),
         SHS = comma(SHS, scale = 1E-6, prefix = "£", suffix = " million", accuracy = 1),
         diff = comma(diff, scale = 1E-6, prefix = "£", suffix = " million", accuracy = 1),
         diffcontr = percent(diffcontr, 1)) %>%
  select(type, HBAI, SHS, diff, diffcontr) %>%
  mutate(type = factor(type, levels = inctypes)) %>%
  knitr::kable(align = "lrrrr") %>%
  kable_styling("striped")

```

### What drives the survey differences across the income distribution {#compdist}

For each household income decile, we looked at the equivalised weekly median income of the main income components, earnings and benefits. This shows that it is _earnings_ that drive the total income distribution, resulting in lower SHS incomes in the lower income deciles, and higher SHS incomes in the top income deciles:
```{r median_comp_quintiles, fig.asp = 0.8}

tidydata %>%
  filter(type %in% c("earn", "ben")) %>%
  group_by(survey, decile, type) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = str_wrap("Weekly median net equivalised household income for the main income types by income decile", 70),
       subtitle = "Includes all households") +
  theme(panel.grid.major.x = element_blank()) +
  facet_wrap(~type, ncol = 1)

```

### Income sources by income decile {#compdec}

```{r component_shares_decile}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded",
         amount >= 0) %>%
  group_by(survey, decile, type) %>%
  summarise(amount = sum(amount*hhwgt*equ)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  group_by(survey, decile) %>%
  ggplot(aes(x = decile, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by (total) household income decile", 70),
       subtitle = "Excludes negative incomes and deductions") +
  facet_wrap(~survey, nrow = 2) +
  theme(legend.position = "right",
        axis.ticks = element_blank()) +
   theme(panel.grid.major.x = element_blank())

```

### Income sources by council area and urban/rural area {#comparea}

```{r inc_sources_council, fig.asp = 0.9}

tidydata %>%
  filter(type != "total",
         type != "ded",
         survey == "SHS") %>%
  group_by(survey, type, council) %>%
  summarise(total = sum(amount),
            n = n()) %>%
  group_by(survey, council) %>%
  mutate(share = total/sum(total)) %>%
  ungroup() %>%
  mutate(survey = fct_reorder(survey, share),
         type = fct_shift(type, 2),
         council = fct_reorder2(council, desc(type), desc(share))) %>%
  filter(n >= 50) %>%
  ggplot(aes(x = council, y = share, fill = type)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  coord_flip() +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Income sources as a share of aggregated total income by council area, SHS", 65),
       subtitle = "Excludes deductions") +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())
  
```

```{r inc_sources_urbrur}

tidydata %>%
  filter(type != "total",
         type != "ded",
         survey == "SHS") %>%
  group_by(type, urbrur) %>%
  summarise(total = sum(amount),
            n = n()) %>%
  group_by(urbrur) %>%
  mutate(share = total/sum(total)) %>%
  ungroup() %>%
  mutate(type = fct_shift(type, 2),
         urbrur = fct_rev(urbrur)) %>%
  ggplot(aes(x = urbrur, y = share, fill = type)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format() ) +
  coord_flip() +
  labs(x = NULL, y = NULL, 
       title = str_wrap("Income sources as a share of aggregated total income by urban/rural class, SHS", 65),
       subtitle = "Excludes deductions") +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())
  
```

### Age profile of council areas and urban/rural areas {#ageprofile}

```{r ages_council, fig.asp = 0.9}

tidydata %>%
  filter(type == "total",
         survey == "SHS") %>%
  group_by(council) %>%
  summarise(sample = n(),
            people = sum(ppwgt),
            children = sum(chwgt),
            waadults = sum(wawgt),
            pensioners = sum(pnwgt)) %>%
  mutate(children = children/people,
         adults = waadults/people,
         pensioners = pensioners/people) %>%
  select(council, children, adults, pensioners) %>%
  gather(group, share, -council) %>%
  ungroup() %>%
  mutate(group = factor(group, levels = people),
         group = fct_rev(group),
         council = fct_reorder2(council, desc(group), desc(share))) %>%
  ggplot(aes(x = council, y = share, fill = group)) + 
  geom_col(position = "stack") +
  scale_fill_manual(values = wes_palettes[["IsleofDogs1"]]) +
  scale_y_continuous(labels = percent_format()) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Age profile of council areas, SHS",
       subtitle = "Proportion of children, working-age adults and pensioners in each council") +
  guides(fill = guide_legend(reverse = TRUE)) +
   theme(panel.grid.major.y = element_blank())
  
```

```{r ages_urbrur}

tidydata %>%
  filter(type == "total",
         survey == "SHS") %>%
  group_by(urbrur) %>%
  summarise(sample = n(),
            people = sum(ppwgt),
            children = sum(chwgt),
            waadults = sum(wawgt),
            pensioners = sum(pnwgt)) %>%
  mutate(children = children/people,
         adults = waadults/people,
         pensioners = pensioners/people) %>%
  select(urbrur, children, adults, pensioners) %>%
  gather(group, share, -urbrur) %>%
  ungroup() %>%
  mutate(group = factor(group, levels = people),
         group = fct_rev(group),
         urbrur = fct_rev(urbrur)) %>%
  ggplot(aes(x = urbrur, y = share, fill = group)) + 
  geom_col(position = "stack") +
  geom_text(aes(y = ifelse(group == "children", 0.05, ifelse(group == "pensioners", 0.85, 0.5)),
                label = percent(share, 1)),
            colour = "white",
            hjust = 0,
            fontface = "bold") +
  scale_fill_manual(values = wes_palettes[["IsleofDogs1"]]) +
  coord_flip() +
  labs(x = NULL, y = NULL,
       title = "Age profile of urban/rural areas, SHS") +
  theme(axis.text.x = element_blank(),
        axis.ticks = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
   theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank())
  
```

### Income sources by household type and economic status {#comptype}

```{r component_shares_hhtype}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded") %>%
  group_by(survey, hhtype, type) %>%
  summarise(amount = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, desc(type), desc(amount))) %>%
  ggplot(aes(x = hhtype, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by household type", 60),
       subtitle = "Excludes deductions") +
  coord_flip() +
  facet_wrap(~survey, ncol = 2) +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())

```

```{r component_shares_eco}

# Make table showing differences in income and income compononents

tidydata %>%
  filter(type != "total",
         type != "ded") %>%
  group_by(survey, HIHemp, type) %>%
  summarise(amount = sum(amount*hhwgt*equ),
            sample = n()) %>%
  ungroup() %>%
  mutate(HIHemp = factor(HIHemp),
         HIHemp = fct_reorder2(HIHemp, desc(type), desc(amount))) %>%
  filter(sample >= 50) %>%
  ggplot(aes(x = HIHemp, y = amount, fill = type)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = cols_types) +
  scale_y_continuous(labels = percent_format()) +
  labs(x  = NULL, y = NULL,
       title = str_wrap("Income sources as a share of aggregated total income by economic status of household head", 60),
       subtitle = "Excludes deductions; sample >= 50") +
  coord_flip() +
  facet_wrap(~survey, ncol = 2) +
  theme(legend.position = "right") +
   theme(panel.grid.major.y = element_blank())

```

## Total income {#income}
### Income distribution {#incdist}

```{r income_distributions}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey) %>%
  mutate(weight = ppwgt/sum(ppwgt)) %>%
  ggplot(aes(x = amount, 
             weight = weight, 
             colour = survey, fill = survey )) +
  geom_vline(xintercept = HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = SHSmedian, colour = cols_survey[2]) +
  geom_vline(xintercept = 0.6*HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = 0.6*SHSmedian, colour = cols_survey[2]) +
  geom_density(size = 1, alpha = 0.5, bw = 0.02) +
  scale_x_log10(labels = comma_format(prefix = "£")) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Net equivalised household income density distributions",
       subtitle = "Vertical lines show poverty thresholds and medians; note log x scale",
       x = "Weekly equivalised net household income",
       y = NULL) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  theme(panel.grid.major.y = element_blank(),
         panel.grid.major.x = element_blank(),
         panel.grid.minor.x = element_blank())

tidydata %>%
  filter(type == "total") %>%
  group_by(survey) %>%
  ggplot(aes(x = amount, weight = ppwgt, colour = survey, fill = survey )) +
  geom_vline(xintercept = HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = SHSmedian, colour = cols_survey[2]) +
  geom_vline(xintercept = 0.6*HBAImedian, colour = cols_survey[1]) +
  geom_vline(xintercept = 0.6*SHSmedian, colour = cols_survey[2]) +
  coord_cartesian(xlim = c(0, 1000)) +
  stat_ecdf(geom = "step", size = 1, alpha = 0.5) +
  geom_text(data = tail(tidydata, 1L), 
            aes(x = HBAImedian + 20, y = 1, label = "Medians"), 
            colour = "grey20",
            hjust = 0, 
            show.legend = FALSE) +
  geom_text(data = tail(tidydata, 1L), 
            aes(x = 0.6*HBAImedian + 10, y = 1, label = "Poverty lines"), 
            colour = "grey20",
            hjust = 0, 
            show.legend = FALSE) +
  scale_x_continuous(labels = comma_format(prefix = "£"), breaks = c(0, 200, 400, 600, 800, 1000)) +
  scale_y_continuous(labels = percent_format()) +
  scale_color_manual(values = cols_survey) +
  scale_fill_manual(values = cols_survey) +
  labs(title = "Cumulative net equivalised household income distributions",
       subtitle = "Note linear x scale",
       x = "Weekly equivalised net household income",
       y = "Proportion of people") +
   theme(panel.grid.minor.x = element_blank(),
         axis.text.y = element_text())

```

### Median income by income decile {#incdec}

```{r income_deciles}

tidydata %>%
  filter(type == "total") %>%
  group_by(survey, decile) %>% 
  summarise(median = wtd.quantile(amount, probs=0.5, weights = ppwgt),
            mean = wtd.mean(amount, weights = hhwgt)) %>%
  ungroup() %>%
  mutate(decile = factor(decile)) %>%
  ggplot(aes(x = decile, y = median, fill = survey)) +
  geom_col(position = 'dodge') +
  geom_text(aes(y = 40,
                label = comma(median, accuracy = 1, prefix = "£")),
            colour = 'white',
            position = position_dodge(width = 1)) +
  scale_fill_manual(values = cols_survey) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  labs(x = NULL, y = NULL,
       title = "Weekly median net equivalised household income by income decile") +
  theme(panel.grid.major.x = element_blank())

```

### Median income by council area {#inccounc}

Weekly median net equivalised household income and 95% confidence interval of the median:
```{r median_council_ci, fig.asp = 0.7}

# Chart - Median income by council with C.I.
# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI",
                              council %in% popokcouncils) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

HBAI_CI_all <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3) %>%
  mutate(survey = "HBAI") %>%
  select(survey, Median, n, Conf.level, Normal.lower, Normal.upper)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "council",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS",
                              council %in% popokcouncils) %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI_all <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3) %>%
  mutate(survey = "SHS") %>%
  select(survey, Median, Normal.lower, Normal.upper, Conf.level,  n)

rbind(HBAI_CI_all, SHS_CI_all) %>%
  select(survey, Median, Normal.lower, Normal.upper, Conf.level,  n) %>%
  mutate_at(c("Median", "Normal.lower", "Normal.upper"), comma_format(1, prefix = "£")) %>%
           knitr::kable(align = "lrrrrr") %>%
  kable_styling("striped")


SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(council = fct_reorder2(council, survey, desc(Median))) %>%
  ggplot() +
  geom_hline(yintercept = HBAImedian, 
             colour = cols_survey[1], 
             alpha = 0.2, 
             size = 1.5) +
  geom_hline(yintercept = SHSmedian, 
             colour = cols_survey[2], 
             alpha = 0.2, 
             size = 1.5) +
  geom_point(aes(x = council,
                 y = Median, 
                 colour = survey), 
             size = 2) +
  geom_segment(aes(x = council,
                   xend = council,
                   y = Normal.lower, 
                   yend = Normal.upper,
                   colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = str_wrap('Excludes council areas with large population discrepancies; lines show Scotland median', 80)) +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(200, 800)) 
  
```

### Median income by urban/rural area {#incarea}

```{r median_urbrur_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "urbrur",
                data = filter(tidydata, type == "total", survey == "HBAI") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "urbrur",
                data = filter(tidydata, type == "total", survey == "SHS") %>%
                  mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  filter(!is.na(Median)) %>%
  ggplot(aes(x = fct_rev(urbrur), y = Median)) +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(colour = survey), size = 2) +
  geom_segment(aes(xend = urbrur,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(200, 800)) 

```

### Median income by age group {#incage} 

```{r median_agegroup_ci}

# Note that HBAI bootstrap mechanism is SRS!

ch_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>% 
                mutate(weight = chwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

wa_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>% 
                mutate(weight = wawgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

pn_HBAI_CI <- groupwiseMedian2(var = "amount",
                data = filter(tidydata, type == "total", survey == "HBAI") %>% 
                mutate(weight = pnwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

ch_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = chwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

wa_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = wawgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

pn_SHS_CI <- groupwiseMedian3(var = "amount",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>% 
                mutate(weight = pnwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

ch_HBAI_CI$group <- "Children"
wa_HBAI_CI$group <- "WorkingAgeAdults"
pn_HBAI_CI$group <- "Pensioners"

ch_SHS_CI$group <- "Children"
wa_SHS_CI$group <- "WorkingAgeAdults"
pn_SHS_CI$group <- "Pensioners"

HBAI_CI <- rbind(ch_HBAI_CI, wa_HBAI_CI, pn_HBAI_CI) %>%
  mutate(survey = "HBAI")

SHS_CI <- rbind(ch_SHS_CI, wa_SHS_CI, pn_SHS_CI) %>%
  mutate(survey = "SHS")

rbind(HBAI_CI, SHS_CI) %>%
  select(survey, group, Median, Normal.lower, Normal.upper, n) %>%
  mutate(group = factor(group, levels = agegrouplevels),
         group = fct_rev(group)) %>%
  ggplot() +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = group, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = group,
                   xend = group,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(200, 800)) 

```

### Median income by household type {#inchhtype}

```{r median_hhtype_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "hhtype",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  filter(n >= 50) %>%
  mutate(hhtype = factor(hhtype),
         hhtype = fct_reorder2(hhtype, survey, desc(Median))) %>%
  ggplot(aes(x = hhtype, y = Median)) +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = hhtype, y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = hhtype,
                   xend = hhtype,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = 'Lines show Scotland median') +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(200, 800)) 

```

### Median income by economic status of highest income householder {#inceco}

```{r median_eco_ci}

# Note that HBAI bootstrap mechanism is SRS!

HBAI_CI <- groupwiseMedian2(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "HBAI") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

# SHS bootstrap mechanism includes council strata

SHS_CI <- groupwiseMedian3(var = "amount",
                group = "HIHemp",
                data = filter(tidydata, 
                              type == "total", 
                              survey == "SHS") %>%
                mutate(weight = ppwgt),
                conf = 0.95,
                R = 100,
                normal = TRUE,
                basic = FALSE,
                percentile = FALSE,
                digits = 3)

SHS_CI$survey <- "SHS"
HBAI_CI$survey <- "HBAI"

rbind(HBAI_CI, SHS_CI) %>%
  mutate(HIHemp <- factor(HIHemp, levels = empstatnames),
         HIHemp = fct_reorder2(HIHemp, survey, Median)) %>%
  filter(n >= 50 ) %>% 
  ggplot() +
  geom_hline(yintercept = HBAImedian, colour = cols_survey[1], alpha = 0.2, size = 1.5) +
  geom_hline(yintercept = SHSmedian, colour = cols_survey[2], alpha = 0.2, size = 1.5) +
  geom_point(aes(x = fct_rev(HIHemp), y = Median, colour = survey), size = 2) +
  geom_segment(aes(x = HIHemp,
                   xend = HIHemp,
                 y = Normal.lower, 
                 yend = Normal.upper,
                 colour = survey),
               size = 3,
               alpha = 0.5) +
    scale_colour_manual(values = cols_survey) +
    labs(x = NULL,
         y = "Median and 95% C.I",
         title = 'Weekly median net equivalised household income',
         subtitle = "Sample >= 50; lines show Scotland median") +
  scale_y_continuous(labels = comma_format(prefix = "£")) +
  coord_flip(ylim = c(200, 800)) 

```

